\documentclass{article}
\title{PPM Checkpoint}
\author{Kevin Brandstatter}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{floatflt}
\usepackage{graphics}
\newcommand{\farg}[2]{
      \ \ \ #1 & :: #2 \\
}
\begin{document}
\maketitle
\section{Motivation}
\paragraph{}
The checkpoint functionality is a necessary component for the scalability of the application. Take for example the library running on a large cluster of 128+ nodes. If the application runs for a significant period of time, there is a good chance the system will experience a failure during the run which would render the simulation useless, as to retry would require starting the simulation from the beginning. However, with a checkpoint/restart mechanism, the application can periodically save its state, thus if a failure occurs the application can be restarted from the saved state which prevents the loss of previous computation.

\section{Background Information}
\subsection{PPM}
\paragraph{}
The PPM (Parallel Particle Mesh) Library is a middleware for creating distributed memory hybrid particle-mesh simulations. It is designed to simplify the task of writing efficient distributed parallelized code and allow for improved performance of the simulations in parallel and distributed environments.

\subsection{HDF5}
\paragraph{}
HDF5 (hierarchical data format version 5) is a file format for the storage of programmatic data using hierarchies of groups and datasets for organization. It has built in support for storage of Fortran's built in types, and can be used to store complex data by creating compound types. This is the file format used for the storage of the checkpoint data.

\subsection{Fortran Types}
\subsubsection{Intrinsic Types}
\paragraph{}
An intrinsic type is any type that is built into the Fortran programming language. This includes INTEGER, REAL, etc. These are the base units of programming and may be encapsulated into derived types.

\subsubsection{Derived Types}
\paragraph{}
A derived type is a type that is defined in Fortran using the ``TYPE'' Keyword. These are used to encapsulated intrinsic types into more complicated structures, and to reuse attributes by extending other derived types. The derived types of PPM are partially outlined in Section \ref{fig.typechart}.

\subsubsection{Pointer Lists}
\paragraph{}
One limitation of Fortran is that it does not allow arrays of pointers. However, it does allow for arrays of derived types. Because of this, there are several specific derived types whose only purpose is to encapsulate a pointer for use in an array. These are generally referred to in this report as the ``ppm\_t\_ptr'' types as they share this common prefix. Pointer lists are arrays of these types. Since they do not extend anything, they do not belong to any of ppm's typical type families and thus must be handled differently. These differences are outlined further in Section \ref{sec.ptrlists}.

\subsection{Jargon}
\begin{list}{}{}
\item Type Family - A group of types that share a common ancestor. Usually referenced by the highest type in the tree that does not extend any other types.
\item ppm\_t\_ptr - A group of derived types that only serve to encapsulate a pointer to another derived type for use in lists.
\end{list}

\section{General Usage}
\subsection{Building}
Most of the building is handled by using Makefiles. In order to build all that is needed is to modify a few variables in the Makefile and run \emph{make}.
\subsubsection*{src/Makefile, part\_test/gen/Makefile}
\begin{list}{}{}
\item PPMDIR = /path/to/ppm
\item PPMNUMDIR = /path/to/ppmnumerics
\item HDF5 = /path/to/HDF5
\item METIS = /path/to/metis/lib
\end{list}

\subsection{Checkpoint}
\paragraph{}
Checkpointing is done by storing the state of specified variables. The type functions are overloaded so that they can all be called with the same name. To begin open a new checkpoint file with
\begin{quote}
CALL make\_checkpoint\_file(file\_id, filename, error)
\end{quote}
or an existing checkpoint file can be opened with
\begin{quote}
   CALL open\_checkpoint\_file(file\_id, filename, error)
\end{quote}

Once a checkpoint file has been opened, the next step is to store the desired state by storing each variable explicitly. This is done with the following sequence of functions:
\begin{quote}
   pointer\_addr = get\_pointer(variable) ! Get the uid of the variable \\
   CALL store\_type(file\_id, pointer\_addr, variable) ! store the variable \\
   CALL save\_pointer(file\_id, variable\_name, pointer\_addr ! record the pointer for later) \\
\end{quote}

The checkpointing routines start by storing all of a types members, starting with the intrinsic types. Then it calls store\_type on each member that it points to so as to store all of its references. In order to prevent double storage and collisions, the pointers are recorded in a tree structure such that the routine can determine if it needs to proceed. Finally, a reference to the other type is stored with the main type for associative resiliency.

\subsection{Restart/Recover}
\paragraph{}
Most of the restart behavior is expected to be done by a parent application. This module serves to provide access to the data stored by a checkpoint in an inverse way. In this way, it provides more of a recover functionality, so that the application can recover its previous state before beginning its main loop. To do this, open the checkpoint file in the same way as making a file, however, be careful not to use the \emph{make} variety, as it will truncate the file. With the file descriptor, the state can retrieved using the simple set of operations that follow.
\begin{quote}
   CALL get\_saved\_pointer(file\_id, varname, pointer\_addr) \\
   var =\textgreater recover\_DTYPE(file\_id, pointer\_addr, var) ! where DTYPE is the type of var
\end{quote}
\section{Implementation Details}
\subsection{Checkpoint File Format}
\subsubsection{Base File}
\label{sec:basefile}
\begin{list}{}{}
\item /checkpoint\_data - Explicitly saved references
\item /intrinsic - Intrinsic types
\item /ptr\_lists - Stored ptr lists
\item /particles\_stats\_d\_
\item /ppm\_t\_container
\item /ppm\_t\_main\_abstr
\item /ppm\_t\_mapping\_d\_
\item /ppm\_t\_neighlist\_d\_
\item /ppm\_t\_operator\_discr\_
\end{list}

\subsubsection{Data Representation}
\begin{quote}
Ex. /ppm\_t\_container/3068ED0000000000E0C66F0000000000 is a stored object
\end{quote}
\paragraph{}
\begin{floatingfigure}[r]{0.2\textwidth}
   \centering
   \includegraphics[width=0.2\textwidth]{container.eps}
   \caption{Example HDF5 representation}
   \label{fig:datarep}
\end{floatingfigure}
Figure \ref{fig:datarep} Shows what this might look like in an HDF5 context. The format is very simple to understand. First, the module creates a custom HDF5 type for the ppm type based on what members it has. The type compiler (See Section \ref{sec:typefc}) handles the calculation of the number and type of the arguments and creates the necessary HDF5 code to initialize the type. Once the type is created, sub types are added to this type as members identified by the variable name. This makes it easy to read and write attributes to the dataset by variable name.

As an additional note, this example shows how datasets are named. Datasets stored by the checkpoint module are referenced using the calculated or generated pointer address string. This string is 32 characters and is in hexadecimal form for derived types. Intrinsic and ppm\_t\_ptr type pointers are based on an internal counter and prefixed with ``internal''.

Finally, if an element is explicitly saved with the ``save\_pointer'' function, then the dataset name is user defined (conventionally it should be the name of the variable) and the value it holds is the pointer address. Section \ref{sec:ptrrep} explains this in more detail.

\subsubsection{Pointer Representation}
\label{sec:ptrrep}
Take this simple example of a checkpointed particle (Note: unused groups omitted for brevity)
\begin{list}{}{}
\item /checkpoint\_data/parts contains ``3068ED0000000000E0C66F0000000000''
\item /ppm\_t\_main\_abstr/3068ED0000000000E0C66F0000000000 is a stored particle.
\end{list}
In order to keep references, a pointer is stored as a string dataset. This string is the address returned by get pointer, and recorded by the pointer\_tracker module (See Section \ref{sec.ptrtrack}). To re-associate the variable ``parts'' with the correct data, the module can read the pointer address from the ``parts'' dataset. This string is the name of the dataset of the corresponding data. Thus it need only be passed to the appropriate ``recover'' function in order to read and associate the data.

Null pointers are represented by a string of 32 ``0''s.
\subsection{Intrinsic Storage}
\paragraph{}
Intrinsic types (integers, reals, logicals, strings, etc) are stored using a combination of the HDF5 low interface and the lite high level HDF5 API. Currently, If you want to checkpoint an HDF5 type by itself you need to manually call the HDF5 code. The checkpoint module only provides the functions for storing intrinsic types as part of a derived type. However, the checkpoint module does provide support for storage of pointers to intrinsic arrays.

Code for reading and writing intrinsic types and pointers is located in the ``intrinsic'' subdirectory (See Section \ref{sec:dirintrinsic}).

\subsection{Derived Type Storage}
\paragraph{}
In order to store derived types, the module groups each type into a family. This family is based on the highest level parent. For example, one family is the ppm\_t\_main\_abstr because it does not extend anything. For each family, there is a standard set of functions, whose behavior depends on what type is given. The functions provided are make\_type, store, write, read, and a collection of recover statements. The store function is the high level storage function that creates a dataset, writes the type and records the address. It uses the write function, which handles just the writing and storage of the various members. This includes storing pointers which it references and recording a reference to the stored location. The make\_type routine is necessary for generating the type of the dataset, which allocates the space and layout of the HDF5 dataset. Finally, the various recover functions are wrappers to the read function. The read function handles the reading of the data from the given dataset into the type. The recover functions handle the allocation of the appropriate Fortran type and returns a pointer to the newly allocated data. This way it can ensure that the type remains the same after a restart and that all the necessary data is recovered.

All of these functions are computer generated with my specially written type compiler, which is explained in more detail in Section \ref{sec:typefc}.

The code for storing these types is contained in the ``types'' subdirectory (See Section \ref{sec:dirtypes}).

\subsection{Pointer Lists}
\label{sec.ptrlists}
\paragraph{}
Since Fortran does not support arrays of pointers, arrays of ppm\_t\_ptr types were used instead. However, because they do not extend any common class, they could not be stored using built in Fortran polymorphism even though they were identical except for which type they encapsulated. Because of this, it was simple to write templates specifically for these types and do what amounts to a search and replace of the type parameter. This process was automated using scripts so that if future encapsulated types need to be added, they only need to be added to the input file.

The reason these are not generated with def files like other derived types is because they do not work exactly like other derived types. The main difference is that the behavior of the transfer function when calculating the address is more similar to that of an intrinsic type. Because of this, pointer lists are treated as intrinsic types for pointer tracking. Also, because there is not an HDF5 function to store an array of potentially different types, the array is stored as a list of pointer addresses. The pointer addresses actually refer to the encapsulated pointer and not the derived type that it is stored in. Because of this explicit unwrapping, it requires additional code, which is why there is a separate template for these types.

The checkpoint code for these types is contained in the ``pointers'' subdirectory.

\subsection{Pointer Tracking}
\label{sec.ptrtrack}
\paragraph{}
One bit of the challenge in checkpointing is the relational nature of the data and the usage of dynamically allocated memory and pointers. Because of this, the module needs to identify various pointers, tag them with a unique identifier, and be able to re-associate each pointer with the correct target. If this isn't done, restarts could have pointers to duplicate data, where changes in one target would not change in the other. This change in behavior is likely to break the running application as it may rely on the fact that these two pointers should reference the same data. Finally, if a pointer to be inserted matches the hash and type of a recorded pointer, an associated() call determines whether or not they are the same thing.

The source files that handle generating, retrieving, and tracking pointers is contained in the ``pointers'' subdirectory (See Section \ref{sec:dirpointers}). The code for the binary trees resides in the ``trees'' subdirectory (See Section \ref{sec:dirtrees}).

\subsubsection{Calculation}
\paragraph{}
Unfortunately, calculation of pointers in Fortran is not exactly efficient as the data has to do some translating to a common type. Also, calculation for intrinsic types and derived types is different because of internal representation differences. Derived type \emph{pointer address} calculation is fairly simple. We are able to use the \emph{transfer} intrinsic function to convert the derived type reference to a 32 character string. This is unique to a given target which allows the module to identify a target by this string. 

For the intrinsic types, this method does not work. Instead, the module takes the hash of the data with FNVHash in order to provide a method of comparison. Then the pointer is inserted into a binary tree and assigned an incremental identifier. It assumes that variables of the same type, with the same hash are the same target. While not conclusive, this is an adequate assumption for the present and could be improved later depending on the limitations of the language. By recording in this binary tree, the same address can be retrieved for all references that satisfy the equality constraints.

\subsubsection{Trees}
\paragraph{}
Binary trees are used as the mechanism for recording and tracking pointer references. A hash table would be ideal as it would allow for faster lookups and removes, but the complexity of writing one for this module is too much for the time being. Binary trees provide still fast lookup and are also much less complex to implement.

The module uses a top level type of a pair of trees, intrinsic and derived as it proved simpler to differentiate these too than to attempt to completely abstract them. The derived trees store references to derived types and insert and lookup is done based on the value of the \emph{address}. For the intrinsic types, insert and lookup is done with comparisons of the hash and type of the reference.

The trees are mostly used for intrinsic pointer assignment (ie, recording which address given to which reference) and also to record which pointers that have already recovered during the read phase. By storing the references in a tree, duplicate reads can be prevented and associative consistency maintained. That is to say, if a given piece of data has already been recovered and another type references that data, it can be directly associated to the recorded reference instead of duplicating the data.

\subsection{Source Code Layout and Key Files}
The checkpoint source code is organized by function and included into the main modules. All of the relevant code is placed in directories in the \texttt{src/} folder. This section goes more in depth about what code is where, and what that code actually responsible for.

\subsubsection{checkpoint\_hdf5.f}
\paragraph{}
This is the main checkpoint module source file. Th bulk of this file is including the relevant source files for the different components and such. The other main part of this file is to defined the relevant user level interfaces, namely \texttt{store\_type}. This interface combines all of the various store\_type functions into one interface that can be used to genericize the process. This interface is also why types needed to be grouped by ``families'', as two types of the same family in this interface would cause an error as it would not be clear to the compiler which one to use.

The second responsibility of this main file is the handling of the checkpoint file, more specifically, the basic file operations. There is create, open, and close. The open function opens an existing function, and the close closes an open file. The create function is a little more detailed. First it creates a new hdf5 file, then it adds the base set of groups to the file. This creates the base file format shown in Section \ref{sec:basefile}. This ensures that all the groups exist when the module attempts to create datasets for the various types.

\subsubsection{types/}
\label{sec:dirtypes}
\paragraph{}
This directory contains the type definitions and derived type checkpoint code. Each Fortran source file is named according to the type family that it is responsible for. These files are generated with a custom written domain specific language from the corresponding \texttt{def} file using the \texttt{typefc.pl} script. This process is described in more detail in Section \ref{sec:typefc}.

The source files that are generated provide the key functions for storage and recovery of derived types. The functions provided are \texttt{make\_type\_}, \texttt{store\_type\_}, \texttt{write\_type\_}, \texttt{read\_type\_}, and several \texttt{recover} functions. The recover functions are generated for each type in the family. This is necessary because in order to satisfy the static typing of Fortran, the function must return a pointer to the same type as is requested. Otherwise there could be an issue of the program treating the data as the wrong type. These functions are suffixed with the type of the pointer that they return. The other subroutines are suffixed with the family name, or the highest common ancestor.

The \texttt{make\_type} subroutine is used to create a custom HDF5 datatype with all the properties of the target PPM datatype. It is called by the \texttt{store\_type} function in order to provide the datatype for the newly created dataset.

The \texttt{store\_type} subroutine is higher level function that is responsible for handling tasks needed before writing data to disk. In detail, it first looks up the type to store in the pointer\_trees to determine if it has already been stored. If it has not been, it calls the appropriate \texttt{make\_type} function in order to get the datatype, then it creates a new HDF5 dataset with this datatype in the appropriate group (See Section \ref{sec:basefile} for information about the dataset groups). Next, it calls the \texttt{write\_type} function, which does the work of writing the input to the dataset. Once thats completed, it closes the various handles as necessary and finishes.

The \texttt{write\_type} subroutine handles writing the individual members of the data to the dataset. It makes heavy use of SELECT TYPE statements to determine which members it needs to store. This allows one write routine to be able to write all the different types in a given family. As an added layer of abstraction, this function does not have to make any calls to the hdf5 library. Its main task is to determine what to write. The low level writing of types is passed of to the \texttt{write\_attribute} interface that is explained in Section \ref{sec:dirintrinsic}. Also, to ensure a complete map, this routine will call \texttt{store\_type} on any associated pointers and record the pointer address. This way references to other types can be retained (See Section \ref{sec:ptrrep} for an explanation of how pointers are represented).

The \texttt{read\_type} subroutine is essentially the inverse of \texttt{write\_type}. It determines the type that it should read, and then uses the \texttt{read\_attribute} interface (See Section \ref{sec:dirintrinsic} to initialize the data with the saved data. If the attribute to read is a pointer, it is also recovered using the appropriate \texttt{recover} function.

The \texttt{recover} functions are necessary wrappers to the read subroutines. Their task is to determine the type that is intended to be read, and to allocate the space for it. However, before it allocates space, it first looks up the address in the pointer\_tree. If it exists it returns the appropriate pointer. This maintains the reference tree of the application before the checkpoint. If the pointer is not in the tree, it then needs to be restored. This is done by reading a special member from the target dataset. This dataset gives a ``type\_id''. This is an integer that refers to an enumeration of the allocatable types. With this id the recover function can determine what the actual type of the data was at the time of checkpoint. This is necessary because it is often the case the the pointer returned is an abstract type that could refer to a number of different types. It is important to be able to save the actual type status in order to know what type to allocate. Once the appropriate type is allocated, it is passed to the \texttt{read\_type} function, which like the \texttt{write\_function} can determine what members to read based on the input type. After reading the data, a pointer to this data is returned to the caller.

As a final note, it is important to point out that there is no generic \texttt{recover\_type} interface at the moment. This is do to an issue mentioned briefly before in regards to Fortran interfaces. The issue is that when the interface has ``ambiguous'' references. In this case it is the fact that two functions may have the same interface, but all that differs is the input type. For these functions, because there are several for each type family, the interface cannot distinguish which one to use for the abstract types. This is because they satisfy the parameters of more than one of the functions and thus is ambiguous.

\subsubsection{intrinsic/}
\label{sec:dirintrinsic}
\paragraph{}
This directory is the essentially the core component to the checkpoint functionality. This is where the code for writing data to datasets exists. The primary functions of these files is to facilitate storage of intrinsic types, as well as writing intrinsic types to datasets based on attribute name. The different functions are grouped by file.

The \texttt{get\_pointers.f} file contains the functions for generating a pointer address for an intrinsic type. It makes use of the pointer\_tracker module (See Section \ref{sec:pointertracker}) to keep track of references to intrinsic types. These functions are grouped into the \texttt{get\_pointer} interface alongside the derived types for ease of use.

\texttt{store\_types.f} provides all of the \texttt{store\_type} functions for intrinsic types. These are included in the \texttt{store\_type} interface alongside the derived types.

\texttt{recover\_type.f} provides all of the \texttt{recover\_type} functions for the various intrinsic types. These are included in the \texttt{recover\_type} interface alongside the derived types.

\texttt{write\_attributes.f} contains the functions for writing intrinsic data type members to HDF5 datasets. Given a dataset identifier, attribute name, and the data, these functions will make the appropriate HDF5 API calls to store the data in the dataset. \texttt{read\_attributes.f} provide the inverse to the write function, that is reading the data from a specific dataset attribute into a designated destination. These groupings are genericized by the \texttt{write\_attribute} and \texttt{read\_attribute} interfaces defined in \texttt{interfaces.f}

\subsubsection{pointer\_tracker.f}
\label{sec:pointertracker}
\paragraph{}
This file is the main file for the pointer\_tracker module. It defines the hashing function that is used for comparing/ordering the intrinsic types in the trees, and includes the relevant files necessary for pointer tracking from the pointers directory (See Section \ref{sec:dirpointers}). Finally, it instantiates an instance of a pointer\_group. A pointer\_group is a type that contains a derived type pointer tree and an intrinsic type pointer tree. This structure and its purpose is discussed further in Section \ref{sec:dirtrees}.

\subsubsection{pointers/}
\label{sec:dirpointers}
\paragraph{}
This directory contains the code that involves handling various kinds of pointers to derived types. The \texttt{ppm\_pointers.f} file is auto generated from a type list (See Section \ref{sec:gen_get_ptr}), and provides the \texttt{get\_pointer} function for each of those types. The file \texttt{ppm\_pointer\_interface.f} is also auto-generated and encapsulates the subroutines into the \texttt{get\_pointer} interface so that it can be used generically for all types.

The secondary function provided by this directory is the storage of the ppm\_t\_ptrs. The file \texttt{ppm\_t\_ptr.f} is an auto-generated file (See Section \ref{sec:store_ptr_list}) that provides the read, write, store, make\_type, and recover functions needed to checkpoint them.

These files are included by the pointer\_tracker module and utilize the trees (See Section \ref{sec:dirtrees}) for tracking pointer references.

\subsubsection{trees/}
\label{sec:dirtrees}
\paragraph{}
This directory contains the code for the pointer trees. The pointer trees are binary tree structures used to organize the references into a searchable form. This way the module can do reference checking of the stored pointers to maintain that pointers that point to the same reference before a checkpoint, also point to the same reference after recovery.

The file \texttt{tree\_abstract.f} contains the functions for inserting, and looking up pointers in the trees, and \texttt{tree\_abstract\_typedef.f} contains the type definitions for all of the tree data types. A tree type must be created for each type family, as a tree node contains a pointer that must have a defined type. Because of this, we can use one tree type for all types that extend the root type, but not for others. These types are auto-generated from a list of types. The other part that is auto-generated is some code for a \texttt{check\_associated} function which allows the module to check whether two pointers are equivalent. More information about this auto-generation is covered in Section \ref{sec:make_trees}.

There are two distinct tree types, intrinsic and derived, that are separated because of the differences in how these insert pointers. For the derived tree, the pointer address is already known, so it can be inserted directly using the pointer address as a unique identifier. For the intrinsic types, when storing a new pointer, the module can only produce a hash. This hash is used to traverse the intrinsic tree to insert it, or to match if it has already been stored. It confirms equality with the \texttt{check\_associated} function when the hashes of two pointers are equal. If it is a new pointer, it is assigned a new address. For recovery the address is known so lookup works the same way for both derived and intrinsic types.

To provide some abstraction between intrinsic and derived types, there is the pointer\_group data type. This data type contains an intrinsic tree and a derived tree. Using the subroutine \texttt{pointer\_insert} to put either type into a pointer\_group allows the data structure to determine which tree to insert into, and handle any additional steps, such as pointer assignment that may need to be do not. The interfaces \texttt{lookup\_pointer} and \texttt{exists\_pointer} provide a generic way to lookup pointers or check if it exists in the tree and are called by passing the appropriate tree member of the pointer\_group.

\subsubsection{doc/}
\paragraph{}
This directory contains these documentation files. The documentation is in PDF format, and generated by \LaTeX

\section{Scripts Documentation}
\paragraph{}
In order to make life easier and maintain sanity amidst a sea of Fortran code that just seemed to repeat itself a thousand times, a set of scripts in perl were developed in conjunction with the main code base in order to generate large amounts of repetitive code from templates. While much of this could have been done with INCLUDES and preprocessor directives, scripts seem to be a bit more elegant as they allow for more flexibility of design and features. For example, it can generate all the varieties of a function into one file and include the file once, instead of using a include file and including it N times with different parameters. However, since these scripts are not exactly standard or particularly well commented, it is important to discus what they do and how they work.
\subsection{typefc.pl}
\label{sec:typefc}
\paragraph{}
The typefc script is essentially a type compiler. It takes a type definition and generates the functions required to store and recover the various types. It uses the type.f.in file as a template for each type. It then parses a definition file to learn the types and relations, generate the necessary section of code, and insert them into the template.
\subsubsection{Invocation}
\begin{quote}
   typefc.pl input.def output.f
\end{quote}
\subsubsection{The .def file format}
\newcommand{\syn}[2]{
   \begin{tabular}{lp{0.7\textwidth}}
      #1 - & #2
   \end{tabular}
}
The def file is a very simple DSL that is parsed to generate the required Fortran code. It has only a few syntactical features and is designed to look similar to Fortran definitions.
\begin{list}{}{}
\item \syn {type}{Begins a type definition}
\item \syn{Fortran\_type name [number]}{Defines a member of an intrinsic Fortran type. Optional parameter number is used for arrays and may be a variable}
\item \syn{pointer type\_name}{Defines a pointer to some type}
\item \syn{end}{Ends the type/allocatable definition}
\item \syn{allocatable}{Begins enumeration of the allocatable types}
\end{list}
Also, for pointers to dimensions of intrinsic types, the type is of the form:
\begin{quote}
   typeNd\_pointer where type = the intrinsic type, N = 1,2 (n dimensions) \\
   ex: integer2d\_pointer for a 2 dimensional integer
\end{quote}
\subsubsection{Example def file}
\begin{tabbing}
! Example definition file \\
type \= some\_type ! Main type is some\_type \\
\> integer anInt ! An Integer member \\
\> real aReal ! A Real member \\
\> pointer some\_other\_type ! a reference to another type \\
\> type \= sub\_type ! define a type that extends some\_type \\
\> \> integer arr 10 ! An integer array \\
\> end ! Ends the sub type definition \\
end ! ends the main type definition \\
allocatable \\
\> some\_dtype ! not an abstract type that extends some\_type \\
end \\
\end{tabbing}

\subsubsection{Script Design}
\paragraph{}
The script operation is fairly simple. The DSL is designed to be an LL Grammar which allows the parser to be very simple to implement and modify. The general parsing method is stack based, where each level is a different type. This stack is build using a basic REPL (Read eval print loop). The operations are simple. First it reads a line from the input. Then it evaluates it. If it is a type, it pushes a new context onto the stack. In this implementation, the \emph{stack} is created through the use of recursive calls to the parse function, which eliminates the need for additional data structures, as the built in scoping handles the context stacking. If it is some type, the evaluator generates the required Fortran code for each section (read, write, make\_type) and returns it to the parent. The parent collects all of these statements and formats them. When an \emph{end} statement is reached, the definitions are wrapped in a type select statement and incorporated into the parent. If it is the parent, then the type parsing is complete.

Within the \emph{allocatable} statement, the parser simply collects the types, and then generates an \emph{allocate block}. This allocate block is used to allocate the correct type during recover. During storage, the types are enumerated, and the current type is recorded in the checkpoint. On recover, this is recovered and used to allocate the data to the appropriate type. This is necessary to allow for the higher level polymorphism to exist while still retaining the data from the lower level types.

\subsection{gen\_get\_ptr.pl}
\label{sec:gen_get_ptr}
\paragraph{}
This script is used to generate the functions for getting a pointer address for a specific reference. It uses a simple replace for each type and a common template to generate the functions, and also outputs an interface that abstracts the individual functions into a generic \emph{get\_pointer} function
\subsubsection{Input}
\begin{list}{}{}
\item pointer.in - Template file for get\_ptr function for standard(derived) types
\item typelist.in - List of standard types to generate get\_ptr functions for
\item ptr\_pointers.in - Template file for get\_ptr function for ppm\_t\_ptr types
\item ptrlist.in - List of ppm\_t\_ptr types to generate get\_ptr function for
\end{list}
\subsubsection{Output}
\begin{list}{}{}
\item ppm\_pointers.f - get\_ptr* functions for derived types
\item ppm\_pointers\_interfaces.f - get\_pointer interface for all types (including intrinsic types)
\end{list}

\subsection{store\_ptr\_list.pl}
\label{sec:store_ptr_list}
\paragraph{}
As a legacy issue that should be addressed at some point, the initial template does not have built in support for storing arrays of derived types. Because of this it is necessary to use a different template for the ppm\_t\_ptr types. This also makes it easier as they do not extend any common type that could be leveraged for abstraction, thus it is easier to provide a pseudo layer of abstraction by using the same template for each. The script does essentially the same thing as the type compiler, in that it provides the store, write, read, recover functions, however it uses a custom template as the types follow a common format.
\subsubsection{Files}
\begin{list}{}{}
\item ptrlist.in - List of ppm\_t\_ptr types to generate functions for
\item ppm\_t\_ptr.f.in - Template file
\item ppm\_t\_ptr.f - Output file containing subroutine definitions for all types.
\end{list}

\subsection{make\_trees.pl}
\label{sec:make_trees}
\paragraph{}
In order to store the types in a generic tree, there have to be trees that store each family and extend the root tree type. Thus, this script generates the tree definitions for the various types so that they can be stored in a single tree.
\subsubsection{Input}
\begin{list}{}{}
\item tree\_abstract.f.in - Base file of common routines for trees, includes some generic ones
\item tree\_abstract\_typedef.f.in - Base file for tree type definitions. Contains top level and intrinsic definitions
\item typelist.in - list of parent derived types to make trees for
\item ptr\_list.in - list of ppm\_t\_ptr types to make trees for
\end{list}
\subsubsection{Output}
\begin{list}{}{}
\item tree\_abstract\_typedef.f - Tree typedefs for the various types
\item tree\_abstract.f - Subroutines for modifying/accessing the trees
\end{list}

\section{Future Work}
\subsection{PHDF5}
\paragraph{}
In the future, the goal will be to support PHDF5, which is a parallel version of HDF5 to allow concurrent writes in order to improve performance. Currently the checkpoint module does not support this, and the operations are done in serial.

\section{API}
\subsection{Subroutines/Functions}
\begin{tabular}{p{0.2\textwidth}p{0.8\textwidth}}
   & CALL make\_checkpoint\_file(filename, file\_id) \\
   Make a new checkpoint
                    & \begin{tabular}{ll}
                       \farg{INTEGER(HID\_T), INTENT(OUT)}{file\_id}
                       \farg{CHARACTER(LEN=*), INTENT(IN)}{filename}
                       \farg{INTEGER, INTENT(OUT)}{error}
                     \end{tabular} \\
                    [1ex] \hline
   & CALL open\_checkpoint\_file(file\_id, filename, error) \\
   Open checkpoint file
                    & \begin{tabular}{ll}
                       \farg{INTEGER(HID\_T), INTENT(OUT)}{file\_id}
                       \farg{CHARACTER(LEN=*), INTENT(IN)}{filename}
                       \farg{INTEGER, INTENT(OUT)}{error}
                     \end{tabular} \\
                    [1ex] \hline
   & CALL close\_checkpoint\_file(file\_id, error) \\
   Close checkpoint file
                    & \begin{tabular}{ll}
                       \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                       \farg{INTEGER, INTENT(OUT)}{error}
                     \end{tabular} \\
                    [1ex] \hline
   & CALL store\_type(file\_id, ptr\_addr, ptr) \\
   Store a variable
                    & \begin{tabular}{ll}
                       \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                       \farg{CHARACTER(LEN=*), INTENT(IN)}{ptr\_addr}
                       \farg{INTEGER, INTENT(OUT)}{error}
                     \end{tabular} \\
                    [1ex] \hline
   & ptr =\textgreater recover\_TYPE(file\_id, ptr\_addr, ptr) \\
   Recover a stored type
                         & \begin{tabular}{ll}
                          \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                          \farg{CHARACTER(LEN=*), INTENT(IN)}{ptr\_addr}
                          \farg{CLASS(TYPE), POINTER}{ptr}
                       \end{tabular} \\ [1ex] \hline
   & CALL save\_pointer(file\_id, varname, ptr\_addr) \\
   Save a pointer
                         & \begin{tabular}{ll}
                          \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                          \farg{CHARACTER(LEN=*), INTENT(IN)}{varname}
                          \farg{CHARACTER(LEN=*), INTENT(IN)}{ptr\_addr}
                       \end{tabular} \\ [1ex] \hline
   & CALL get\_saved\_pointer(file\_id, varname, ptr\_addr) \\
   Read a saved pointer
                         & \begin{tabular}{ll}
                          \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                          \farg{CHARACTER(LEN=*), INTENT(IN)}{varname}
                          \farg{CHARACTER(LEN=*), INTENT(OUT)}{ptr\_addr}
                       \end{tabular} \\ [1ex] \hline
\end{tabular}

\subsection{Internal Functions}
\begin{tabular}{p{0.2\textwidth}p{0.8\textwidth}}
   & CALL make\_type\_DTYPE(ptr, type\_id) \\
   Make HDF5 type representation
                                 & \begin{tabular}{ll}
                                   \farg{CLASS(DTYPE), POINTER, INTENT(IN)}{ptr}
                                   \farg{INTEGER(HID\_T), INTENT(OUT)}{type\_id}
                                \end{tabular} \\ [1ex] \hline
   & CALL write\_DTYPE(file\_id, dset\_id, ptr) \\
   Write type
                      & \begin{tabular}{lp{\textwidth}}
                           \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                           \farg{INTEGER(HID\_T), INTENT(IN)}{dset\_id}
                           \farg{CLASS(DTYPE), POINTER, INTENT(IN)}{ptr}
                        \end{tabular} \\ [1ex] \hline
   & CALL read\_DTYPE(file\_id, dset\_id, ptr) \\
   Read a type
                      & \begin{tabular}{lp{\textwidth}}
                           \farg{INTEGER(HID\_T), INTENT(IN)}{file\_id}
                           \farg{INTEGER(HID\_T), INTENT(IN)}{dset\_id}
                           \farg{CLASS(DTYPE), POINTER, INTENT(IN)}{ptr}
                        \end{tabular} \\ [1ex] \hline
   & CALL pointer\_insert(tree\_group, node, intr\_ptr) \\
   Insert pointer
                  & \begin{tabular}{lp{\textwidth}}
                        \farg{CLASS(pointer\_trees)}{tree\_group}
                        \farg{CLASS(pointer\_btree)}{node}
                        \farg{CHARACTER(LEN=*), OPTIONAL}{intr\_ptr}
                     \end{tabular} \\ [1ex] \hline
   & CALL delete\_tree(some\_tree) \\
   Delete tree
                  & \begin{tabular}{lp{\textwidth}}
                      \farg{CLASS(intrinsic\_tree|derived\_tree), POINTER}{some\_tree}
                   \end{tabular} \\ [1ex] \hline
   & rval = exists\_pointer(key, some\_tree) \\
   Check for existing tree
               & \begin{tabular}{lp{\textwidth}}
                   \farg{CHARACTER(LEN=*), INTENT(IN)}{key}
                   \farg{CLASS(intrinsic\_tree|derived\_tree), POINTER}{some\_tree}
                \end{tabular} \\ [1ex] \hline
   & CALL lookup\_pointer(key, some\_tree, ptr) \\
   Lookup pointer in tree
               & \begin{tabular}{lp{\textwidth}}
                   \farg{CHARACTER(LEN=*), INTENT(IN)}{key}
                   \farg{CLASS(intrinsic\_tree|derived\_tree), POINTER}{some\_tree}
                   \farg{CLASS(intrinsic\_tree|derived\_tree), POINTER}{ptr}
                \end{tabular} \\ [1ex] \hline
                & CALL delete\_tree(some\_tree) \\
   Deleting a pointer tree
                & \begin{tabular}{lp{\textwidth}}
                     \farg{pointer\_btree}{some\_tree}
                  \end{tabular} \\ [1ex] \hline
                & CALL check\_associated(treenode, newnode) \\
   Check if two pointers are the same (tree context)
                & \begin{tabular}{lp{\textwidth}}
                     \farg{pointer\_btree}{treenode}
                     \farg{pointer\_btree}{newnode}
                  \end{tabular} \\ [1ex] \hline


\end{tabular}

\subsection{Currently Supported Types}
This section lists all the types for which a \emph{recover} function is generated. Read/write/store/make\_type functions are only generated for the patriarch class (the one that does not extend anything) and use SELECT statements to operate using polymorphism for all children.
\begin{list}{}{}
\item particles\_stats\_d\_
\item ppm\_t\_container
\item ppm\_c\_neighlist\_d\_
\item ppm\_c\_part\_prop\_d\_
\item ppm\_v\_main\_abstr
\item ppm\_c\_part\_mapping\_d\_
\item ppm\_c\_operator\_discr\_
\item ppm\_t\_main\_abstr
\item ppm\_t\_discr\_data
\item ppm\_t\_part\_prop\_d\_
\item ppm\_t\_discr\_kind
\item ppm\_t\_particles\_d\_
\item ppm\_t\_operator\_
\item ppm\_t\_mapping\_d\_
\item ppm\_t\_part\_mapping\_d\_
\item ppm\_t\_neighlist\_d\_
\item ppm\_t\_operator\_discr\_
\end{list}

\subsection{Type Chart}
\begin{figure}[h!]
   \label{fig.typechart}
   \includegraphics[width=\textwidth]{ClassDiagram.png}
   \caption{Class relationships. Arrows are extends, lines are reference relations}
\end{figure}

\end{document}
