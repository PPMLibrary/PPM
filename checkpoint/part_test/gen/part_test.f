program adv

use ppm_autogenerated_global
use ppm_module_core
USE checkpoint_hdf5
implicit none
include 'mpif.h'
INTEGER(HID_T) :: checkpoint_file
character(len=3) :: caller = 'adv'
integer :: info
integer :: comm
integer :: rank
integer :: nproc
real(mk), dimension(:), pointer :: geng6f_cost  => null()
TYPE(ppm_t_particles_d), pointer :: parts
CLASS(ppm_t_particles_d_), pointer :: parts_abstr
class(ppm_t_part_prop_d_), pointer :: dx
class(ppm_t_part_prop_d_), pointer :: procid
class(ppm_t_neighlist_d_), pointer :: nlist
CHARACTER(LEN=ppm_char)   :: failbuf
integer :: gena7k_p
real(ppm_kind_double), dimension(:,:), pointer :: gena7k_x => null()
real(ppm_kind_double), dimension(:), pointer :: gena7k_procid_wp => null()
integer :: gen865_p
real(ppm_kind_double), dimension(:), pointer :: gen865_procid_wp => null()
real(ppm_kind_double), dimension(:,:), pointer :: gen865_dx_wp => null()
real(mk) :: t
integer :: gen1mb_info
  integer, dimension(6) :: bcdef = ppm_param_bcdef_periodic
  real(mk), dimension(3) :: r_pq
  real(mk)               :: r_s_pq2
  real(mk), dimension(3) :: dF
  real(mk)               :: scaldF
  real(mk)               :: cutoff
  real(mk), dimension(3) :: displacement
  real(mk), dimension(:,:), pointer :: xp => NULL()
  real(mk), dimension(:),pointer  :: disp_vector => NULL()
  integer                :: st = 0, vtkcounter=0,nsubs_x,total_part
  real(mk)               :: disp,maxdisp,allmaxdisp
  real(mk)               :: skin
  real(mk)               :: sigma6,sigma12,side_len,x1,y1,z1
  class(ppm_t_part_prop_d_), pointer :: prop => null()
  integer                :: iter_time, map_time, fcalc_time, before_dlb_time,id,j,globalID
  real(mk)               :: time_diff
  integer, dimension(:),pointer   :: nvlist=>NULL()
  integer, dimension(:,:),pointer :: vlist=>NULL()
  character(len=15)               :: vtkfilename
  character(len=3)                :: procbuf
  INTEGER :: error
  CHARACTER(LEN=32) :: pointer_addr
  !CHARACTER(LEN=32) :: init_part = "30E8BF0000000000C09E700000000000"
  !LOGICAL :: TEST_READ = .TRUE.
  LOGICAL :: TEST_READ = .FALSE.

  ! Prepare VTK filename
  write(procbuf,'(I3)')   ppm_nproc
  write(vtkfilename,'(A,A5)') trim(ADJUSTL(procbuf)),'_test'
  
  ! Read input arguments from Ctrl file
  
  
  
  
  
  ! Initialize ppm
  
  call MPI_Init(info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Init failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF
  
  comm = MPI_COMM_WORLD
  
  call MPI_Comm_Size(comm, nproc, info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Comm_Size failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF
  
  call MPI_Comm_Rank(comm, rank, info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Comm_Rank failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF
  
  call define_args
  call parse_args(info)
  if (info .eq. exit_gracefully) then
    goto 9999
  else
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "Parse args failed.",&
        caller, 35 , info)
      GOTO 9999
    END IF
  end if
  
  call ppm_init(3, ppm_kind_double, &
                -14, comm,&
                0, info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "ppm_init failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF

  cutoff = 0.05_mk
  skin = 0.1_mk*cutoff

  ! Create topology
  call ppm_mktopo(topo,domain_decomposition,processor_assignment,min_phys,max_phys,bcdef, cutoff + skin,geng6f_cost,info)

IF (TEST_READ) THEN
      CALL open_checkpoint_file(checkpoint_file, 'checkpoint.h5')

      CALL get_saved_pointer(checkpoint_file, 'parts', pointer_addr)
      parts_abstr => recover_ppm_t_particles_d_(checkpoint_file,pointer_addr, parts_abstr)
      IF (.not. associated(parts_abstr)) THEN
         STOP "Could not read in particle"
      ELSE
         SELECT TYPE(parts_abstr)
         TYPE is(ppm_t_particles_d)
            parts => parts_abstr
            !dx => parts%props%vec(1)%t
            CALL get_saved_pointer(checkpoint_file, 'dx', pointer_addr)
            dx => recover_ppm_t_part_prop_d_(checkpoint_file, pointer_addr, dx)

            procid => parts%props%vec(2)%t
            CALL get_saved_pointer(checkpoint_file, 'procid', pointer_addr)
            procid => recover_ppm_t_part_prop_d_(checkpoint_file, pointer_addr, procid)
            !WRITE(*,*) "xp", (parts%xp(1,info), info=1,10)
            call parts%map_ghosts(info)
            !parts%active_topoid = topo
            !WRITE(*,*) "Mpart", parts%Mpart
            !call parts%comp_neighlist(info)
            call parts%apply_bc(info)
            !nlist => parts%get_neighlist()
            CALL get_saved_pointer(checkpoint_file, 'nlist', pointer_addr)
            nlist => recover_ppm_t_neighlist_d_(checkpoint_file, pointer_addr, nlist)
         END SELECT
      END IF
      CALL close_checkpoint_file(checkpoint_file)
ELSE
! BEGIN INITIALIZATIONS
  ! Create particles
  allocate(parts,stat=info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_alloc, &
      "Could not allocate parts",&
      caller, 43 , info)
    GOTO 9999
  END IF
  call parts%initialize(Npart, info, topoid=topo, distrib=ppm_param_part_init_cartesian, cutoff=cutoff + skin)
  ! Apply boundary conditions
 call parts%apply_bc(info)
  ! Do the global mapping
  call parts%map(info,global=.true.,topoid=topo)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "Global mapping failed.",&
      caller, 47 , info)
    GOTO 9999
  END IF
  ! Create particle properties
  !v = create_property(parts, ppm_dim, "velocity",zero=true)
  !a = create_property(parts, ppm_dim, "acceleration",zero=true)
  !F = create_property(parts, ppm_dim, "force",zero=true)
  !E = create_property(parts, 1, "energy",zero=true)
  
  ! this line, so part create_prop
  call parts%create_prop(info ,name='"displace"',lda=ppm_dim,part_prop=dx,zero=.true.)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "Create property failed!",&
      caller, 53 , info)
    GOTO 9999
  END IF
  
  call parts%create_prop(info ,name='"proc ID"',lda=1,part_prop=procid,zero=.true.)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "Create property failed!",&
      caller, 54 , info)
    GOTO 9999
  END IF
  !displace = create_property(parts,1,"displace",zero=true)
  ! Find the ghost particles
  call parts%map_ghosts(info)

  ! Create neighbor lists (i.e. neighbors of each particle)  
  call parts%comp_neighlist(info,skin=skin,cutoff=cutoff,symmetry=.false.)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "Could not compute neighlist",&
      caller, 60 , info)
    GOTO 9999
  END IF
 nlist => parts%get_neighlist()
   CALL make_checkpoint_file(checkpoint_file, 'checkpoint-end.h5')

   pointer_addr =  get_pointer(parts)
   CALL store_type(checkpoint_file,pointer_addr, parts)
   CALL save_pointer(checkpoint_file, 'parts', pointer_addr)

   pointer_addr = get_pointer(dx)
   CALL store_type(checkpoint_file, pointer_addr, dx)
   CALL save_pointer(checkpoint_file, 'dx', pointer_addr)

   pointer_addr = get_pointer(procid)
   CALL store_type(checkpoint_file, pointer_addr, procid)
   CALL save_pointer(checkpoint_file, 'procid', pointer_addr)

   pointer_addr = get_pointer(nlist)
   CALL store_type(checkpoint_file, pointer_addr, nlist)
   CALL save_pointer(checkpoint_file, 'nlist', pointer_addr)

   CALL close_checkpoint_file(checkpoint_file)
ENDIF
! END INITIALIZATIONS
  ! Time statistics
 call ppm_tstats_setup(1,info)
 call ppm_tstats_add('iteration',iter_time,info)
  ! Enter the time loop
  t = 0.0_mk
  do while (t .le. stop_time)
    call ppm_tstats_tic(iter_time,st+1,info)
    
    !IF (t == 10 ) THEN
      !CALL make_checkpoint_file('checkpoint.h5', checkpoint_file)
      !CALL store_TYPE(checkpoint_file,'p1', parts)
      !CALL close_checkpoint_file(checkpoint_file, info)
      !WRITE(*,*) "write checkpoint"
      !WRITE (*,*) parts%itime
   !ENDIF
    maxdisp = 0.0_mk
    allmaxdisp = 0.0_mk
        WRITE(failbuf,*) "**********TIME STEP**********: ",&
    &    st+1
        parts%itime = parts%itime + 1
        CALL ppm_write(ppm_rank,caller,failbuf,info)
    
    ! Move the particles a bit
    call parts%get_xp(gena7k_x,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting positions parts",&
        caller, 74 , info)
      GOTO 9999
    END IF
    call parts%get(procid,gena7k_procid_wp,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting field procid for parts",&
        caller, 74 , info)
      GOTO 9999
    END IF
    do gena7k_p=1,parts%Npart
      gena7k_x(:,gena7k_p) = gena7k_x(:,gena7k_p) + 0.25_mk*cutoff !displacement 
    end do
    call parts%set_xp(gena7k_x,info)
    
    
    ! Apply the boundary conditions again to correct particle positions
    call parts%apply_bc(info)
    call parts%map(info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "Partial mapping failed.",&
        caller, 79 , info)
      GOTO 9999
    END IF
    
    call parts%get(procid,gen865_procid_wp,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting field procid for parts",&
        caller, 82 , info)
      GOTO 9999
    END IF
    call parts%get(dx,gen865_dx_wp,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting field dx for parts",&
        caller, 82 , info)
      GOTO 9999
    END IF
    do gen865_p=1,parts%Npart
      gen865_dx_wp(:,gen865_p) = sin(cos(sin(cos(tan(sin(sin(cos(30._mk))))))))
      gen865_procid_wp(gen865_p) = ppm_rank
    end do
    
    ! Re-do the ghost mappings
    call parts%map_ghosts(info)
    
    ! Re-compute neighbor lists
    call parts%comp_neighlist(info)
    
    nlist%uptodate = .TRUE.
    
    t = t + dt
    st = st + 1
    call ppm_tstats_toc(iter_time,st,time_diff,info) 
    ! Visualize particles using Paraview
    call ppm_vtk_particles(vtkfilename,parts,info,step=st)
  end do
  call ppm_tstats_collect('time.dat',info)
  
  call ppm_finalize(gen1mb_info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "ppm_finalize failed.",&
      caller, 98 , info)
    GOTO 9999
  END IF
  
  call MPI_Finalize(gen1mb_info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Finalize failed.",&
      caller, 98 , info)
    GOTO 9999
  END IF
9999 continue
end program


