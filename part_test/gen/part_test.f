program adv

use ppm_autogenerated_global
use ppm_module_core
USE checkpoint_hdf5
implicit none
include 'mpif.h'
INTEGER(HID_T) :: checkpoint_file
character(len=3) :: caller = 'adv'
integer :: info
integer :: comm
integer :: rank
integer :: nproc
real(mk), dimension(:), pointer :: geng6f_cost  => null()
type(ppm_t_particles_d), pointer :: parts
class(ppm_t_part_prop_d_), pointer :: dx
class(ppm_t_part_prop_d_), pointer :: procid
class(ppm_t_neighlist_d_), pointer :: nlist
CHARACTER(LEN=ppm_char)   :: failbuf
integer :: gena7k_p
real(ppm_kind_double), dimension(:,:), pointer :: gena7k_x => null()
real(ppm_kind_double), dimension(:), pointer :: gena7k_procid_wp => null()
integer :: gen865_p
real(ppm_kind_double), dimension(:), pointer :: gen865_procid_wp => null()
real(ppm_kind_double), dimension(:,:), pointer :: gen865_dx_wp => null()
real(mk) :: t
integer :: gen1mb_info
  integer, dimension(6) :: bcdef = ppm_param_bcdef_periodic
  real(mk), dimension(3) :: r_pq
  real(mk)               :: r_s_pq2
  real(mk), dimension(3) :: dF
  real(mk)               :: scaldF
  real(mk)               :: cutoff
  real(mk), dimension(3) :: displacement
  real(mk), dimension(:,:), pointer :: xp => NULL()
  real(mk), dimension(:),pointer  :: disp_vector => NULL()
  integer                :: st = 0, vtkcounter=0,nsubs_x,total_part
  real(mk)               :: disp,maxdisp,allmaxdisp
  real(mk)               :: skin
  real(mk)               :: sigma6,sigma12,side_len,x1,y1,z1
  class(ppm_t_part_prop_d_), pointer :: prop => null()
  integer                :: iter_time, map_time, fcalc_time, before_dlb_time,id,j,globalID
  real(mk)               :: time_diff
  integer, dimension(:),pointer   :: nvlist=>NULL()
  integer, dimension(:,:),pointer :: vlist=>NULL()
  character(len=15)               :: vtkfilename
  character(len=3)                :: procbuf

  ! Prepare VTK filename
  write(procbuf,'(I3)')   ppm_nproc
  write(vtkfilename,'(A,A5)') trim(ADJUSTL(procbuf)),'_test'
  
  ! Read input arguments from Ctrl file
  
  
  
  
  
  ! Initialize ppm
  
  call MPI_Init(info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Init failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF
  
  comm = MPI_COMM_WORLD
  
  call MPI_Comm_Size(comm, nproc, info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Comm_Size failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF
  
  call MPI_Comm_Rank(comm, rank, info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Comm_Rank failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF
  
  call define_args
  call parse_args(info)
  if (info .eq. exit_gracefully) then
    goto 9999
  else
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "Parse args failed.",&
        caller, 35 , info)
      GOTO 9999
    END IF
  end if
  
  call ppm_init(3, ppm_kind_double, &
                -14, comm,&
                0, info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "ppm_init failed.",&
      caller, 35 , info)
    GOTO 9999
  END IF

  cutoff = 0.05_mk
  skin = 0.1_mk*cutoff

      CALL OPEN_checkpoint_file('checkpoint.h5', checkpoint_file)
      ALLOCATE (ppm_t_particles_d::parts)
      CALL read_type(checkpoint_file,'p1', parts)
      CALL close_checkpoint_file(checkpoint_file, info)
!  ! Create topology
!  call ppm_mktopo(topo,domain_decomposition,processor_assignment,min_phys,max_phys,bcdef, cutoff + skin,geng6f_cost,info)
!  ! Create particles
!  allocate(parts,stat=info)
!  IF (info.NE.0) THEN
!    info = ppm_error_error
!    CALL ppm_error(ppm_err_alloc, &
!      "Could not allocate parts",&
!      caller, 43 , info)
!    GOTO 9999
!  END IF
!  call parts%initialize(Npart, info, topoid=topo, distrib=ppm_param_part_init_cartesian, cutoff=cutoff + skin)
!  ! Apply boundary conditions
!  call parts%apply_bc(info)
!  ! Do the global mapping
!  call parts%map(info,global=.true.,topoid=topo)
!  IF (info.NE.0) THEN
!    info = ppm_error_error
!    CALL ppm_error(ppm_err_sub_failed, &
!      "Global mapping failed.",&
!      caller, 47 , info)
!    GOTO 9999
!  END IF
!  ! Create particle properties
!  !v = create_property(parts, ppm_dim, "velocity",zero=true)
!  !a = create_property(parts, ppm_dim, "acceleration",zero=true)
!  !F = create_property(parts, ppm_dim, "force",zero=true)
!  !E = create_property(parts, 1, "energy",zero=true)
!  
!  ! this line, so part create_prop
!  call parts%create_prop(info ,name='"displace"',lda=ppm_dim,part_prop=dx,zero=.true.)
!   !CALL make_checkpoint_file('checkpoint.h5', checkpoint_file)
!   !CALL store_TYPE(checkpoint_file,'p1', parts)
!   !CALL close_checkpoint_file(checkpoint_file, info)
!   WRITE (*,*) parts%itime
!  IF (info.NE.0) THEN
!    info = ppm_error_error
!    CALL ppm_error(ppm_err_sub_failed, &
!      "Create property failed!",&
!      caller, 53 , info)
!    GOTO 9999
!  END IF
!  
!  call parts%create_prop(info ,name='"proc ID"',lda=1,part_prop=procid,zero=.true.)
!  IF (info.NE.0) THEN
!    info = ppm_error_error
!    CALL ppm_error(ppm_err_sub_failed, &
!      "Create property failed!",&
!      caller, 54 , info)
!    GOTO 9999
!  END IF
!  !displace = create_property(parts,1,"displace",zero=true)
!  ! Find the ghost particles
!  call parts%map_ghosts(info)
!
!  ! Create neighbor lists (i.e. neighbors of each particle)  
!  call parts%comp_neighlist(info,skin=skin,cutoff=cutoff,symmetry=.false.)
!  IF (info.NE.0) THEN
!    info = ppm_error_error
!    CALL ppm_error(ppm_err_sub_failed, &
!      "Could not compute neighlist",&
!      caller, 60 , info)
!    GOTO 9999
!  END IF
!  nlist => parts%get_neighlist()

  ! Time statistics
  call ppm_tstats_setup(1,info)
  call ppm_tstats_add('iteration',iter_time,info)
  ! Enter the time loop
  t = 0.0_mk
  do while (t .le. stop_time)
    call ppm_tstats_tic(iter_time,st+1,info)
    
    IF (t == 10 ) THEN
      CALL make_checkpoint_file('checkpoint.h5', checkpoint_file)
      CALL store_TYPE(checkpoint_file,'p1', parts)
      CALL close_checkpoint_file(checkpoint_file, info)
      WRITE(*,*) "write checkpoint"
      WRITE (*,*) parts%itime
   ENDIF
    maxdisp = 0.0_mk
    allmaxdisp = 0.0_mk
        WRITE(failbuf,*) "**********TIME STEP**********: ",&
    &    st+1
        parts%itime = parts%itime + 1
        CALL ppm_write(ppm_rank,caller,failbuf,info)
    
    ! Move the particles a bit
    call parts%get_xp(gena7k_x,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting positions parts",&
        caller, 74 , info)
      GOTO 9999
    END IF
    call parts%get(procid,gena7k_procid_wp,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting field procid for parts",&
        caller, 74 , info)
      GOTO 9999
    END IF
    do gena7k_p=1,parts%Npart
      gena7k_x(:,gena7k_p) = gena7k_x(:,gena7k_p) + 0.25_mk*cutoff !displacement 
    end do
    call parts%set_xp(gena7k_x,info)
    
    
    ! Apply the boundary conditions again to correct particle positions
    call parts%apply_bc(info)
    call parts%map(info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "Partial mapping failed.",&
        caller, 79 , info)
      GOTO 9999
    END IF
    
    call parts%get(procid,gen865_procid_wp,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting field procid for parts",&
        caller, 82 , info)
      GOTO 9999
    END IF
    call parts%get(dx,gen865_dx_wp,info)
    IF (info.NE.0) THEN
      info = ppm_error_error
      CALL ppm_error(ppm_err_sub_failed, &
        "getting field dx for parts",&
        caller, 82 , info)
      GOTO 9999
    END IF
    do gen865_p=1,parts%Npart
      gen865_dx_wp(:,gen865_p) = sin(cos(sin(cos(tan(sin(sin(cos(30._mk))))))))
      gen865_procid_wp(gen865_p) = ppm_rank
    end do
    
    ! Re-do the ghost mappings
    call parts%map_ghosts(info)
    
    ! Re-compute neighbor lists
    call parts%comp_neighlist(info)
    
    nlist%uptodate = .TRUE.
    
    t = t + dt
    st = st + 1
    call ppm_tstats_toc(iter_time,st,time_diff,info) 
    ! Visualize particles using Paraview
    call ppm_vtk_particles(vtkfilename,parts,info,step=st)
  end do
  call ppm_tstats_collect('time.dat',info)
  
  call ppm_finalize(gen1mb_info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "ppm_finalize failed.",&
      caller, 98 , info)
    GOTO 9999
  END IF
  
  call MPI_Finalize(gen1mb_info)
  IF (info.NE.0) THEN
    info = ppm_error_error
    CALL ppm_error(ppm_err_sub_failed, &
      "MPI_Finalize failed.",&
      caller, 98 , info)
    GOTO 9999
  END IF
9999 continue
   WRITE (*,*) parts%itime
   !CALL OPEN_checkpoint_file('checkpoint.h5', checkpoint_file)
   !CALL read_type(checkpoint_file,'p1', parts)
   !CALL close_checkpoint_file(checkpoint_file, info)
   WRITE (*,*) parts%itime
end program


