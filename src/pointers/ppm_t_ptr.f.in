      ! Store routines for DTYPE
         SUBROUTINE make_type_DTYPE(type_ptr, dtype_id)
               IMPLICIT NONE
               TYPE(DTYPE), DIMENSION(:), INTENT(IN) :: type_ptr
               INTEGER(HID_T), INTENT(OUT) :: dtype_id
               INTEGER(HID_T) :: string_id
               INTEGER(HSIZE_T), DIMENSION(1) :: dims
               INTEGER rank
               INTEGER error
               INTEGER(HSIZE_T) :: tsize, offset
               INTEGER(HSIZE_T) :: csize

               offset = 0
               tsize = 0
               rank = 1

               ! Calculate datatype size
               CALL h5tget_size_f(H5T_NATIVE_CHARACTER, csize, error)
               dims(1) = size(type_ptr)
               tsize = dims(1) * 32 * csize;
               !CALCULATE_STUB

               ! Create/Expand the datatype
               ! Create the pointer string type
               CALL h5tcreate_f(H5T_STRING_F, 32*csize, string_id, &
                    error)
               CALL h5tarray_create_f(string_id, rank, dims, dtype_id, &
                  error)

            END SUBROUTINE make_type_DTYPE

            SUBROUTINE store_DTYPE(cpfile_id, &
                  type_ptr_id, type_ptr)
               INTEGER(HID_T), INTENT(IN) :: cpfile_id
               INTEGER(HID_T) :: group_id, type_id, dset_id, &
                  dspace_id
               CHARACTER(LEN=*), INTENT(IN) :: type_ptr_id
               TYPE(DTYPE), DIMENSION(:) :: type_ptr
               INTEGER error
               LOGICAL link_exist
               WRITE (*,*) "storing DTYPE" !INFO

               CALL h5lexists_f(cpfile_id, 'ptr_lists'//type_ptr_id, &
                  link_exist, error)
               IF (link_exist) THEN
                  RETURN
               END IF
               CALL h5gopen_f(cpfile_id, 'ptr_lists', &
                  group_id, error)

               ! Make our dataset
               CALL make_type_DTYPE(type_ptr, type_id) ! get type
               CALL h5screate_f(H5S_SCALAR_F, dspace_id, error)  ! get space
               CALL h5dcreate_f(group_id, type_ptr_id, type_id, &
                   dspace_id, dset_id, error)

               CALL write_DTYPE(cpfile_id, dset_id, type_ptr)
               !CALL write_TYPE(dset_id, type_ptr)

               CALL h5dclose_f(dset_id, error)
               CALL h5sclose_f(dspace_id, error)

               CALL h5gclose_f(group_id, error)
               !WRITE (*,*) "stored DTYPE"
            END SUBROUTINE store_DTYPE

            SUBROUTINE write_DTYPE(cpfile_id, dset_id, type_ptr)
               IMPLICIT NONE
               INTEGER(HID_T), INTENT(IN) :: dset_id
               INTEGER(HID_T), INTENT(in) :: cpfile_id
               INTEGER(HID_T) :: type_id
               CHARACTER(LEN=32), DIMENSION(:), ALLOCATABLE ::&
                     pointer_addresses
               TYPE(DTYPE), DIMENSION(:), INTENT(IN) :: type_ptr
               INTEGER(HSIZE_T), DIMENSION(1) :: dims
               INTEGER i, rank, error

               CALL make_type_DTYPE(type_ptr, type_id) ! get type
               rank = 1
               dims(1) = size(type_ptr)
               ALLOCATE(CHARACTER(LEN=32)::pointer_addresses(dims(1)))
               DO i=1, int(dims(1))
                  IF (associated(type_ptr(i)%t)) THEN
                     pointer_addresses(i) = get_pointer(type_ptr(i)%t)
                     CALL store_type(cpfile_id, pointer_addresses(i), &
                        type_ptr(i)%t)
                  ELSE
                     pointer_addresses(i) = &
                          '00000000000000000000000000000000'
                  END IF
               ENDDO
               CALL h5dwrite_f(dset_id, type_id, pointer_addresses, &
                  dims, error)
               CALL h5tclose_f(type_id, error)
               !WRITE_STUB
               DEALLOCATE(pointer_addresses)

            END SUBROUTINE write_DTYPE
            RECURSIVE FUNCTION recover_DTYPE(cpfile_id, &
                  type_ptr_id, type_ptr2) RESULT(type_ptr)
               IMPLICIT NONE
               TYPE(DTYPE), DIMENSION(:), POINTER :: type_ptr, type_ptr2
               INTEGER(HID_T), INTENT(in) :: cpfile_id
               INTEGER(HID_T) :: group_id, dset_id
               INTEGER(HID_T) :: array_id
               CHARACTER(LEN=*) :: type_ptr_id
               LOGICAL :: link_exist
               INTEGER i, rank, error
               !INTEGER(HSIZE_T) :: tsize
               CHARACTER(LEN=32), DIMENSION(:), ALLOCATABLE ::&
                     pointer_addresses
               INTEGER(HSIZE_T), DIMENSION(1) :: dims
               CLASS(intrinsic_tree), POINTER :: type_ptr_node
               ! for holding the encapsulated type
               CLASS(derived_tree), POINTER :: contained_type
               TYPE(DTYPE_tree), POINTER :: new_pointer_node

               CALL h5lexists_f(cpfile_id, 'ptr_lists/'//type_ptr_id, &
                  link_exist, error)
               IF (.NOT. link_exist) THEN
                  WRITE(*,*) "Does not exist" !ERROR
                  RETURN
               END IF
               type_ptr2 => null()

               CALL h5gopen_f(cpfile_id, 'ptr_lists', &
                  group_id, error)

               !CALL h5screate_f(H5S_SCALAR_F, dspace_id, error)  ! get space
               CALL h5dopen_f(group_id, type_ptr_id, dset_id, &
                   error)

               ! if we have it lets use it
               CALL lookup_POINTER(type_ptr_id, pointer_data%itree, type_ptr_node)
               IF (associated(type_ptr_node)) THEN
                  WRITE(*,*) "We have already have this, associating" !INFO
                  ! stupid type casting necessary
                  SELECT TYPE(type_ptr_node)
                  CLASS is (DTYPE_tree)
                     type_ptr => type_ptr_node%val
                  END SELECT
                  RETURN
               END IF

               ! Otherwise lets initialize the pointer and start
               ! get the info, mainly the dimension

               ! Try to fix the dim issue
               rank = 1
               CALL h5dget_type_f(dset_id, array_id, error)
               CALL h5tget_array_dims_f(array_id, dims, error)
               !CALL h5tget_array_dims_f(tclass, rank, dims, &
               !      array_id, error)
               !CALL h5ltget_dataset_info_f(group_id, type_ptr_id, dims,&
               !   tclass, tsize, error)
               ! Reading in the data
               WRITE (*,*) "Dimension of ptr is ", dims(1) !DEBUG
               ALLOCATE(DTYPE::type_ptr(int(dims(1))))
               ALLOCATE(CHARACTER(LEN=32)::pointer_addresses(dims(1)))
               WRITE(*,*) "Recording pointer in tree" !INFO
               ALLOCATE(new_pointer_node)
               new_pointer_node%val => type_ptr
               new_pointer_node%key = type_ptr_id
               CALL pointer_insert(pointer_data, new_pointer_node)
               ! read the pointer address from the dataset
               CALL h5dread_f(dset_id, array_id, pointer_addresses, &
                  dims, error)
               WRITE(*,*) "Pointer Array Populated" !INFO
               ! Now we iterate over the pointers and read as necessary
               DO i=1, int(dims(1))
                  IF (.NOT. pointer_addresses(i) == &
                           "00000000000000000000000000000000") THEN
                     WRITE(*,*) "Check for pointer ", pointer_addresses(i) !INFO
                     CALL lookup_pointer(pointer_addresses(i), &
                              pointer_data%dtree, contained_type)
                     IF (associated(contained_type)) THEN
                        WRITE(*,*) "FIX ME i need to be associated here" !CRITICAL
                        ! need some black magic
                        !SELECT TYPE (contained_type)
                        !CLASS is(CTYPE_tree)
                        !   type_ptr(i)%t => contained_type%val
                        !END SELECT
                     ELSE
                        WRITE(*,*) "Recovering DTYPE member: ", i !INFO
                        type_ptr(i)%t => recover_CTYPE(cpfile_id, &
                              pointer_addresses(i), type_ptr(i)%t)
                     ENDIF
                  ELSE
                     WRITE(*,*) "Null pointer" !INFO
                     type_ptr(i)%t => null()
                  ENDIF
               ENDDO
               !CALL h5tclose_f(type_id, error)
               DEALLOCATE(pointer_addresses)
               WRITE (*,*) "Done reading, recording in tree" !INFO

               CALL h5dclose_f(dset_id, error)
               CALL h5gclose_f(group_id, error)
            END FUNCTION recover_DTYPE
