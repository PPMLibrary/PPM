include macro overload_function(func_name)
% conf.ppm.type.all.each do |type_name|
SUBROUTINE <%=func_name%>_<%= type_name %>
% end
end macro

include macro ppm_create_collection(coll_type,el_type,generate="concrete",vec=false,def_ptr=true,abstr_type=nil,ptr_type=nil)
% gen = generate.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% def_pointer = def_ptr.to_s.match(/(true|t|yes|y|1)$/i) != nil
% vector = vec.to_s.match(/(true|t|yes|y|1)$/i) != nil
% element_type = 'ppm_t_'+el_type.to_s
% if abstr_type == nil
% abstr_type = coll_type.to_s + '_'
% end
% if ptr_type == nil
% element_ptr_type = 'ppm_t_ptr_'+el_type.to_s
% element_ptr_type = element_ptr_type.gsub( /_\Z/m, "" )
% else
% element_ptr_type = 'ppm_t_ptr_'+ptr_type.to_s
% end
% if vector
% collection_type = 'ppm_v_'+coll_type.to_s
% abstr_collection_type = 'ppm_v_'+abstr_type.to_s
      !collection of pointers to objects (removing an element
      !does not delete the object itself, just the pointer to the object)
% else
% collection_type = 'ppm_c_'+coll_type.to_s
% abstr_collection_type = 'ppm_c_'+abstr_type.to_s
      !collection of objects (stored as pointers, but removing an element
      !also deletes the object itself)
% end
% if def_pointer && gen != "extend"
      TYPE  <%= element_ptr_type %>
          CLASS(<%= element_type %>), POINTER :: t => NULL()
      END TYPE <%= element_ptr_type %>
% end
% proc_list = ['begin','next','last','prev','destroy','exists','has','get_id','push','remove','grow_size','at']
% if gen == "concrete"
      !
      TYPE,EXTENDS(ppm_t_container) :: <%= collection_type %>
          TYPE(<%= element_ptr_type %>), DIMENSION(:), POINTER :: vec => NULL()
          !CLASS(<%= element_type %>),                  POINTER :: iterator => NULL()
      CONTAINS
%proc_list.each do |func_name|
          PROCEDURE :: <%=func_name%>  => <%= collection_type %>_<%=func_name%>
% end
      END TYPE <%= collection_type %>
% end
%#
% if gen == "extend"
%#
      !
      TYPE,EXTENDS(<%= abstr_collection_type %>) :: <%= collection_type %>
      CONTAINS
%proc_list.each do |func_name|
          PROCEDURE :: <%=func_name%> => <%= collection_type %>_<%=func_name%>
% end
      END TYPE <%= collection_type %>
% end
% if gen == "abstract"
%#
      !
      TYPE,ABSTRACT,EXTENDS(ppm_t_container) :: <%= collection_type %>
          TYPE(<%= element_ptr_type %>), DIMENSION(:), POINTER :: vec => NULL()
          !CLASS(<%= element_type %>),                  POINTER :: iterator => NULL()
      CONTAINS
%proc_list.each do |func_name|
          PROCEDURE(<%= collection_type %>_<%=func_name%>), DEFERRED :: <%=func_name%>
% end
      END TYPE <%= collection_type %>
% end
end macro


include macro ppm_create_collection_interfaces(coll_type,el_type,vec=false)
% element_type = 'ppm_t_'+el_type.to_s
% vector = vec.to_s.match(/(true|t|yes|y|1)$/i) != nil
% if vector
% collection_type = 'ppm_v_'+coll_type.to_s
      !collection of pointers to objects (removing an element
      !does not delete the object itself, just the pointer to the object)
% else
% collection_type = 'ppm_c_'+coll_type.to_s
      !collection of objects (stored as pointers, but removing an element
      !also deletes the object itself)
% end
      !FIRST ELEMENT
      FUNCTION <%= collection_type %>_begin(this) RESULT (iterator)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          CLASS(<%= element_type %>),    POINTER       :: iterator
      END FUNCTION <%= collection_type %>_begin
      !NEXT ELEMENT
      FUNCTION <%= collection_type %>_next(this) RESULT (iterator)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          CLASS(<%= element_type %>),    POINTER       :: iterator
      END FUNCTION <%= collection_type %>_next
      !PREVIOUS ELEMENT
      FUNCTION <%= collection_type %>_prev(this) RESULT (iterator)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT):: this
          CLASS(<%= element_type %>),    POINTER      :: iterator
      END FUNCTION <%= collection_type %>_prev
      !LAST ELEMENT
      FUNCTION <%= collection_type %>_last(this) RESULT (iterator)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          CLASS(<%= element_type %>),    POINTER       :: iterator
      END FUNCTION <%= collection_type %>_last
      !DESTROY COLLECTION
      SUBROUTINE <%= collection_type %>_destroy(this,info)
          IMPORT :: <%= collection_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          INTEGER,                       INTENT(  OUT) :: info
      END SUBROUTINE <%= collection_type %>_destroy
      !EXISTS
      FUNCTION <%= collection_type %>_exists(this,id) RESULT(exists)
          IMPORT :: <%= collection_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(IN   ) :: this
          INTEGER,                       INTENT(IN   ) :: id
          LOGICAL                                      :: exists
      END FUNCTION <%= collection_type %>_exists
      !HAS
      FUNCTION <%= collection_type %>_has(this,element) RESULT(has)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          CLASS(<%= element_type %>),    TARGET        :: element
          LOGICAL                                      :: has
      END FUNCTION <%= collection_type %>_has
      !GET_ID
      FUNCTION <%= collection_type %>_get_id(this,element) RESULT(id)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          CLASS(<%= element_type %>),    TARGET        :: element
          INTEGER                                      :: id
      END FUNCTION <%= collection_type %>_get_id
      !PUSH ELEMENT INTO COLLECTION
      SUBROUTINE <%= collection_type %>_push(this,element,info,id)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          CLASS(<%= element_type %>),    POINTER       :: element
          INTEGER,                       INTENT(  OUT) :: info
          INTEGER, OPTIONAL,             INTENT(  OUT) :: id
      END SUBROUTINE <%= collection_type %>_push
      !REMOVE ELEMENT FROM COLLECTION
      SUBROUTINE <%= collection_type %>_remove(this,info,element)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>),        INTENT(INOUT) :: this
          INTEGER,                              INTENT(  OUT) :: info
          CLASS(<%= element_type %>), OPTIONAL, TARGET        :: element
      END SUBROUTINE <%= collection_type %>_remove
      !GROW COLLECTION SIZE
      SUBROUTINE <%= collection_type %>_grow_size(this,info)
          IMPORT :: <%= collection_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          INTEGER,                       INTENT(  OUT) :: info
      END SUBROUTINE <%= collection_type %>_grow_size
      !AT
      FUNCTION <%= collection_type %>_at(this,i) RESULT (element)
          IMPORT :: <%= collection_type %>,<%= element_type %>
          IMPLICIT NONE
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          INTEGER,                       INTENT(IN   ) :: i
          CLASS(<%= element_type %>),    POINTER       :: element
      END FUNCTION <%= collection_type %>_at
end macro


include macro ppm_create_collection_procedures(coll_type,el_type,vec=false,ptr_type=nil)
% element_type = 'ppm_t_'+el_type.to_s
% vector = vec.to_s.match(/(true|t|yes|y|1)$/i) != nil
% if vector
% collection_type = 'ppm_v_'+coll_type.to_s
      !collection of pointers to objects (removing an element
      !does not delete the object itself, just the pointer to the object)
% else
% collection_type = 'ppm_c_'+coll_type.to_s
      !collection of objects (stored as pointers, but removing an element
      !also deletes the object itself)
% end
% if ptr_type == nil
% element_ptr_type = 'ppm_t_ptr_'+el_type.to_s
% element_ptr_type = element_ptr_type.gsub( /_\Z/m, "" )
% else
% element_ptr_type = 'ppm_t_ptr_'+ptr_type.to_s
% end
      !BEGIN
      FUNCTION <%= collection_type %>_begin(this) RESULT (iterator)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          CLASS(<%= element_type %>),    POINTER       :: iterator

          IF (this%nb.GT.0) THEN
             this%iter_id = this%min_id
             IF (this%iter_id.LE.this%max_id) THEN
                iterator => this%vec(this%min_id)%t
                RETURN
             ENDIF
          ENDIF
          iterator => NULL()
      END FUNCTION <%= collection_type %>_begin

      !NEXT
      FUNCTION <%= collection_type %>_next(this) RESULT (iterator)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          CLASS(<%= element_type %>),    POINTER       :: iterator

          IF (this%nb.GT.0) THEN
             this%iter_id = this%iter_id + 1
             IF (this%iter_id.GE.this%min_id.AND.this%iter_id.LE.this%max_id) THEN
                iterator => this%vec(this%iter_id)%t
                RETURN
             ENDIF
          ENDIF
          iterator => NULL()
      END FUNCTION <%= collection_type %>_next

      !PREVIOUS
      FUNCTION <%= collection_type %>_prev(this) RESULT (iterator)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          CLASS(<%= element_type %>),    POINTER       :: iterator

          IF (this%nb.GT.0) THEN
             this%iter_id = this%iter_id - 1
             IF (this%iter_id.GE.this%min_id .AND. this%iter_id.LE.this%max_id) THEN
                iterator => this%vec(this%iter_id)%t
                RETURN
             ENDIF
          ENDIF
          iterator => NULL()
      END FUNCTION <%= collection_type %>_prev
      !LAST
      FUNCTION <%= collection_type %>_last(this) RESULT (iterator)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          CLASS(<%= element_type %>),    POINTER       :: iterator

          IF (this%nb.GT.0) THEN
             this%iter_id = this%max_id
             IF (this%iter_id.GE.this%min_id) THEN
                iterator => this%vec(this%max_id)%t
                RETURN
             ENDIF
          ENDIF
          iterator => NULL()
      END FUNCTION <%= collection_type %>_last

      !DESTROY CONTAINER
      SUBROUTINE <%= collection_type %>_destroy(this,info)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          INTEGER,                       INTENT(  OUT) :: info

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          CLASS(<%= element_type %>), POINTER :: p

          start_subroutine("<%= "#{collection_type}" %>_destroy")

%if !vector
          p => this%begin()
          DO WHILE(ASSOCIATED(p))
             !yaser I think this is necessary for complete destroyment
             CALL p%destroy(info)
             or_fail("p%destroy")

             DEALLOCATE(P,STAT=info)
             or_fail_dealloc("Could not deallocate collection element")

             p => this%next()
          ENDDO
%end
          IF (ASSOCIATED(this%vec)) DEALLOCATE(this%vec,STAT=info)
          or_fail_dealloc("Could not deallocate collection array")

          NULLIFY(this%vec)

          this%iter_id = 0
          this%min_id = 0
          this%max_id = 0
          this%nb = 0
          this%vec_size=0

          end_subroutine()
      END SUBROUTINE <%= collection_type %>_destroy

      !EXISTS
      FUNCTION <%= collection_type %>_exists(this,id) RESULT(exists)
          !!! Check whether an element exists and can be accessed at this id

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(IN   ) :: this
          !!! Data structure containing the particles

          INTEGER,                       INTENT(IN   ) :: id
          !!! id where the data is stored

          LOGICAL                                      :: exists
          !!! Return status, on success 0.

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          !-------------------------------------------------------------------------
          !  Check arguments
          !-------------------------------------------------------------------------
          IF (id.LE.0 .OR. id.LT.this%min_id .OR. id.GT.this%max_id) THEN
             exists = .FALSE.
             RETURN
          ENDIF
          IF (.NOT.ASSOCIATED(this%vec)) THEN
             exists = .FALSE.
             RETURN
          ENDIF
          IF (.NOT.ASSOCIATED(this%vec(id)%t)) THEN
             exists = .FALSE.
             RETURN
          ENDIF
          exists = .TRUE.

          RETURN
      END FUNCTION <%= collection_type %>_exists

      !HAS
      FUNCTION <%= collection_type %>_has(this,element) RESULT(has)
          !!! Check whether an element is present in the collection (slow...)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT):: this
          !!! Data structure containing the particles

          CLASS(<%= element_type %>),    TARGET       :: element
          !!! element which is being searched for

          LOGICAL                                     :: has
          !!! true if this element belongs to the collection

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          CLASS(<%= element_type %>), POINTER :: p

          has = .TRUE.

          p => this%begin()
          DO WHILE(ASSOCIATED(p))
             IF (ASSOCIATED(p,element)) RETURN
             p => this%next()
          ENDDO

          has = .FALSE.
          RETURN
      END FUNCTION <%= collection_type %>_has

      !GET_ID
      FUNCTION <%= collection_type %>_get_id(this,element) RESULT(id)
          !!! Returns the id of an element in the collection (slow...)
          !!! Returs -1 if the element is not found.

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this
          !!! Data structure containing the particles

          CLASS(<%= element_type %>),    TARGET        :: element
          !!! Element which is being searched for

          INTEGER                                      :: id
          !!! id where the data is stored

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          CLASS(<%= element_type %>), POINTER :: p

          p => this%begin()
          DO WHILE(ASSOCIATED(p))
             IF (ASSOCIATED(p,element)) THEN
                id = this%iter_id
                RETURN
             ENDIF
             p => this%next()
          ENDDO

          id = -1
          RETURN
      END FUNCTION <%= collection_type %>_get_id

      !PUSH
      SUBROUTINE <%= collection_type %>_push(this,element,info,id)
          !!! add an element into the collection

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          CLASS(<%= element_type %>),    POINTER       :: element

          INTEGER,                       INTENT(  OUT) :: info
          INTEGER, OPTIONAL,             INTENT(  OUT) :: id
          !!! index of the element in the collection

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          start_subroutine("<%= "#{collection_type}" %>_push")

          !add the element at the end of the array
          this%min_id = 1
          this%max_id = this%max_id + 1
          this%nb = this%nb + 1
          IF (PRESENT(id)) id = this%max_id

          IF (this%max_id.GT.this%vec_size) THEN
             CALL this%grow_size(info)
             or_fail("could not grow <%= "#{collection_type}" %> to a larger size")
          ENDIF

          IF (ASSOCIATED(this%vec(this%max_id)%t)) THEN
             fail("Pointer at position of new element is already associated. Something wrong in the Collection data structure")
          ENDIF

          this%vec(this%max_id)%t => element

          check_associated_noscope(<#this%vec(this%max_id)%t#>,"Pushing element into collection failed unexpectedly")

%if !vector
          element => NULL()
%end

          end_subroutine()
      END SUBROUTINE <%= collection_type %>_push

      !REMOVE
      SUBROUTINE <%= collection_type %>_remove(this,info,element)
          !!! If element is present, remove it from the collection
          !!! else, remove the current element (as defined by the iterator pointer)
          !!! If id is present, remove it from the collection, but keep the ordering
          !!! of the collection, the removed part willl be linked to the next item

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>),       INTENT(INOUT) :: this

          INTEGER,                             INTENT(  OUT) :: info

          CLASS(<%= element_type %>), OPTIONAL, TARGET       :: element

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          INTEGER :: del_id
          INTEGER :: iter_id_save

          start_subroutine("<%= "#{collection_type}" %>_remove")

          iter_id_save = this%iter_id

          IF (PRESENT(element)) THEN
             del_id = this%get_id(element)
             IF (del_id.LT.0) RETURN
          ELSE
             del_id = this%iter_id
          ENDIF

%if !vector
          !deallocate the element
          CALL this%vec(del_id)%t%destroy(info)
%else
          !do not deallocate the element. Just nullify the pointer.
%end

          !swap with the last non-empty element of the collection
          IF (this%max_id.GT.this%min_id) THEN
             this%vec(del_id)%t => this%vec(this%max_id)%t
             this%vec(this%max_id)%t => NULL()
          ELSE
             this%vec(del_id)%t => NULL()
          ENDIF

          this%nb = this%nb - 1
          this%max_id = this%max_id - 1
          this%iter_id = iter_id_save - 1
          IF (this%nb.EQ.0 .OR. this%max_id.EQ.0) this%min_id = 0

          end_subroutine()
      END SUBROUTINE <%= collection_type %>_remove

      !GROW COLLECTION SIZE
      SUBROUTINE <%= collection_type %>_grow_size(this,info)
          !!! Reallocate collection to a larger size
          !!! (twice the size seems good)

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          INTEGER,                       INTENT(  OUT) :: info

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------
          TYPE(<%= element_ptr_type %>), DIMENSION(:), POINTER :: vec_temp

          INTEGER :: i

          start_subroutine("<%= "#{collection_type}" %>_grow_size")

          IF (this%vec_size.LE.0.OR..NOT.ASSOCIATED(this%vec)) THEN
             !if the array is empty, allocate with a reasonable size
             this%vec_size = 8
             ALLOCATE(<%= element_ptr_type %>::this%vec(this%vec_size),STAT=info)
             or_fail_alloc("could not allocate collection array")
          ELSE
             !if the array is full, double its size
             ! allocate a temporary array to store the current element
             ALLOCATE(vec_temp(this%vec_size),STAT=info)
             or_fail_alloc("could not allocate temporary array")

             ! copy the elements to the temporary array
             DO i=1,this%vec_size
                vec_temp(i)%t => this%vec(i)%t
             ENDDO

             !reallocate the collection to a larger size
             DEALLOCATE(this%vec,STAT=info)
             or_fail_dealloc("could not deallocate collection array")

             ALLOCATE(<%= element_ptr_type %>::this%vec(2*this%vec_size),STAT=info)
             or_fail_alloc("could not allocate collection array")

             !copy the elements back from the temporary array to the collection
             DO i=1,this%vec_size
                this%vec(i)%t => vec_temp(i)%t
             ENDDO

             this%vec_size=2*this%vec_size

             DEALLOCATE(vec_temp,STAT=info)
             or_fail_dealloc("could not deallocate temporary array")
             NULLIFY(vec_temp)
          ENDIF

          end_subroutine()
      END SUBROUTINE <%= collection_type %>_grow_size

      !AT
      FUNCTION <%= collection_type %>_at(this,i) RESULT (element)
          !!! Access the i-th element of the collection
          !!! (the ordering is the same as that given by the iterators next()
          !!! begin(), prev() and last() )
          !!! If there is less than i elements in the collection, the function
          !!! returns a NULL pointer.

          IMPLICIT NONE

          !-------------------------------------------------------------------------
          !  Arguments
          !-------------------------------------------------------------------------
          CLASS(<%= collection_type %>), INTENT(INOUT) :: this

          INTEGER,                       INTENT(IN   ) :: i

          CLASS(<%= element_type %>),    POINTER       :: element

          !-------------------------------------------------------------------------
          !  Local variables
          !-------------------------------------------------------------------------

          IF (i.GE.this%min_id.AND.i.LE.this%max_id.AND.i.NE.0) THEN
             element => this%vec(i)%t
             this%iter_id=i
             DO WHILE (.NOT.ASSOCIATED(element))
                IF (this%iter_id.GT.this%max_id) THEN
                   element => NULL()
                   RETURN
                ENDIF
                element => this%next()
             ENDDO
          ELSE
             element => NULL()
          ENDIF
          RETURN
      END FUNCTION <%= collection_type %>_at
end macro
