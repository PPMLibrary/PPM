macro define_collection_type(element_type)
<% collection_type    = element_type.to_s.sub("ppm_t","ppm_c") %>
TYPE, EXTENDS(<%= collection_type %>_) ::  <%= collection_type %>
        CONTAINS
            PROCEDURE       :: begin   => <%= collection_type %>_begin
            PROCEDURE       :: next    => <%= collection_type %>_next
            PROCEDURE       :: last    => <%= collection_type %>_last
            PROCEDURE       :: prev    => <%= collection_type %>_prev
            PROCEDURE       :: destroy => <%= collection_type %>_destroy
            PROCEDURE       :: exists  => <%= collection_type %>_exists
            PROCEDURE       :: push    => <%= collection_type %>_push
            PROCEDURE       :: remove  => <%= collection_type %>_remove
END TYPE
end macro

macro define_abstract_collection_type(element_type)
<% element_ptr_type   = element_type.to_s.sub("ppm_t","ppm_t_ptr").chop%>
<% collection_type    = element_type.to_s.sub("ppm_t","ppm_c") %>
TYPE  <%= element_ptr_type %>
    CLASS(<%= element_type %>),                  POINTER :: t => NULL()
END TYPE 

TYPE,ABSTRACT,EXTENDS(ppm_t_container) ::  <%= collection_type %>
    TYPE(<%= element_ptr_type %>),DIMENSION(:), POINTER :: vec => NULL()
    CLASS(<%= element_type %>),                 POINTER :: iterator => NULL()
    CONTAINS
    PROCEDURE(<%= collection_type %>_begin),  DEFERRED :: begin
    PROCEDURE(<%= collection_type %>_next),   DEFERRED :: next 
    PROCEDURE(<%= collection_type %>_prev),   DEFERRED :: prev 
    PROCEDURE(<%= collection_type %>_last),   DEFERRED :: last 
    PROCEDURE(<%= collection_type %>_destroy),DEFERRED :: destroy 
    PROCEDURE(<%= collection_type %>_exists), DEFERRED :: exists 
    PROCEDURE(<%= collection_type %>_push),   DEFERRED :: push 
    PROCEDURE(<%= collection_type %>_remove), DEFERRED :: remove 
END TYPE 
end macro

macro define_abstract_collection_interfaces(element_type)
<% collection_type    = element_type.to_s.sub("ppm_t","ppm_c") %>
!FIRST ELEMENT
FUNCTION <%= collection_type %>_begin(this) RESULT (iterator)
    IMPORT <%= collection_type %>,<%= element_type %>
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>),POINTER             :: iterator
END FUNCTION
!NEXT ELEMENT
FUNCTION <%= collection_type %>_next(this) RESULT (iterator)
    IMPORT <%= collection_type %>,<%= element_type %>
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>),POINTER             :: iterator
END FUNCTION
!PREVIOUS ELEMENT
FUNCTION <%= collection_type %>_prev(this) RESULT (iterator)
    IMPORT <%= collection_type %>,<%= element_type %>
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>),POINTER             :: iterator
END FUNCTION
!LAST ELEMENT
FUNCTION <%= collection_type %>_last(this) RESULT (iterator)
    IMPORT <%= collection_type %>,<%= element_type %>
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>),POINTER             :: iterator
END FUNCTION
!DESTROY COLLECTION
SUBROUTINE <%= collection_type %>_destroy(this,info)
    IMPORT <%= collection_type %>,<%= element_type %>
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    INTEGER,                       INTENT(OUT  )   :: info
END SUBROUTINE
!EXISTS
FUNCTION <%= collection_type %>_exists(this,id,caller) RESULT(exists)
    IMPORT <%= collection_type %>
    CLASS(<%= collection_type %>)                  :: this
    INTEGER,                       INTENT(IN   )   :: id
    LOGICAL                                        :: exists
    CHARACTER(LEN = *),OPTIONAL                    :: caller
END FUNCTION
!PUSH ELEMENT INTO COLLECTION
SUBROUTINE <%= collection_type %>_push(this,element,info,id)
    IMPORT <%= collection_type %>,<%= element_type %>
    CLASS(<%= collection_type %>)      :: this
    CLASS(<%= element_type %>),POINTER :: element
    INTEGER,               INTENT(OUT) :: info
    INTEGER,OPTIONAL,      INTENT(OUT) :: id
END SUBROUTINE
!REMOVE ELEMENT FROM COLLECTION
SUBROUTINE <%= collection_type %>_remove(this,info,id)
    IMPORT <%= collection_type %>
    CLASS(<%= collection_type %>)      :: this
    INTEGER,          INTENT(  OUT)    :: info
    INTEGER,OPTIONAL, INTENT(IN   )    :: id
END SUBROUTINE
end macro


macro define_collection_procedures(element_type)
<% element_ptr_type   = element_type.to_s.sub("ppm_t","ppm_t_ptr") %>
<% collection_type    = element_type.to_s.sub("ppm_t","ppm_c") %>
!BEGIN
FUNCTION <%= collection_type %>_begin(this) RESULT (iterator)
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>_),POINTER   :: iterator

    IF (this%nb.GT.0) THEN
        this%iter_id = this%min_id
        IF (this%iter_id.GE.this%min_id .AND. this%iter_id.LE.this%max_id) THEN
            SELECT TYPE (t => this%vec(this%min_id)%t)
            TYPE IS (<%= element_type %>)
                iterator => t
                RETURN
            END SELECT
        ENDIF
    ENDIF
    iterator => NULL()
END FUNCTION
!NEXT
FUNCTION <%= collection_type %>_next(this) RESULT (iterator)
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>_),POINTER   :: iterator

    IF (this%nb.GT.0) THEN
        this%iter_id = this%iter_id + 1
        IF (this%iter_id.GE.this%min_id .AND. this%iter_id.LE.this%max_id) THEN
            SELECT TYPE (t => this%vec(this%iter_id)%t)
            TYPE IS (<%= element_type %>)
                iterator => t
                RETURN
            END SELECT
        ENDIF
    ENDIF
    iterator => NULL()
END FUNCTION
!PREVIOUS
FUNCTION <%= collection_type %>_prev(this) RESULT (iterator)
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>_),POINTER   :: iterator

    IF (this%nb.GT.0) THEN
        this%iter_id = this%iter_id - 1
        IF (this%iter_id.GE.this%min_id .AND. this%iter_id.LE.this%max_id) THEN
            SELECT TYPE (t => this%vec(this%iter_id)%t)
            TYPE IS (<%= element_type %>)
                iterator => t
                RETURN
            END SELECT
        ENDIF
    ENDIF
    iterator => NULL()
END FUNCTION
!LAST
FUNCTION <%= collection_type %>_last(this) RESULT (iterator)
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>_),POINTER   :: iterator

    IF (this%nb.GT.0) THEN
        this%iter_id = this%max_id
        IF (this%iter_id.GE.this%min_id .AND. this%iter_id.LE.this%max_id) THEN
            SELECT TYPE (t => this%vec(this%max_id)%t)
            TYPE IS (<%= element_type %>)
                iterator => t
                RETURN
            END SELECT
        ENDIF
    ENDIF
    iterator => NULL()

END FUNCTION

!DESTROY CONTAINER
SUBROUTINE <%= collection_type %>_destroy(this,info)
    CLASS(<%= collection_type %>), INTENT(INOUT)   :: this
    CLASS(<%= element_type %>_),POINTER :: p => NULL()
    INTEGER, INTENT(OUT) :: info

    CHARACTER(LEN=ppm_char)            :: caller = "<%= collection_type %>_destroy"
    REAL(KIND(1.D0))                   :: t0

    CALL substart(caller,t0,info)

    p => this%begin()
    DO WHILE(ASSOCIATED(p))
        CALL p%destroy(info)
        $or_fail_dealloc("Could not deallocate collection element")
        p => this%next()
    ENDDO
    IF (ASSOCIATED(this%vec))  DEALLOCATE(this%vec,STAT=info)
    $or_fail_dealloc("Could not deallocate collection array")
    this%iter_id = 0
    this%min_id = 0
    this%max_id = 0
    this%nb = 0
    this%vec_size=0

    CALL substop(caller,t0,info)
    9999 CONTINUE
END SUBROUTINE

!EXISTS
FUNCTION <%= collection_type %>_exists(this,id,caller) RESULT(exists)
    !!!------------------------------------------------------------------------!
    !!! Check whether a neighbor list exists and can be accessed at this id
    !!!------------------------------------------------------------------------!
    !-------------------------------------------------------------------------
    !  Arguments
    !-------------------------------------------------------------------------
    CLASS(<%= collection_type %>)                  :: this
    !!! Data structure containing the particles
    INTEGER,                       INTENT(IN   )   :: id
    !!! id where the data is stored
    LOGICAL                                        :: exists
    !!! Return status, on success 0.
    CHARACTER(LEN = *),OPTIONAL                    :: caller
    !!! Calling routine
    !-------------------------------------------------------------------------
    ! local variables
    !-------------------------------------------------------------------------
    CHARACTER(LEN = ppm_char)               :: lcaller
    INTEGER                                 :: info

    IF (PRESENT(caller)) THEN
        lcaller = TRIM(ADJUSTL(caller))
    ELSE
        lcaller = 'ppm_DS_exists'
    ENDIF
    exists = .FALSE.
    !-------------------------------------------------------------------------
    ! Check arguments
    !-------------------------------------------------------------------------
    IF (id.LE.0 .OR. id.LT.this%min_id .OR. id.GT.this%max_id) THEN
        $fail("Invalid id for this data structure, use create() first",ppm_err_argument,info,9999,lcaller)
    ENDIF

    9999 CONTINUE
    RETURN

END FUNCTION

!PUSH
SUBROUTINE <%= collection_type %>_push(this,element,info,id)
    !!! add an element into the collection
    CLASS(<%= collection_type %>)      :: this
    CLASS(<%= element_type %>_),POINTER     :: element
    INTEGER,               INTENT(OUT) :: info
    INTEGER,OPTIONAL,      INTENT(OUT) :: id
    !!! index of the element in the collection

    TYPE(<%= element_ptr_type %>),DIMENSION(:),POINTER :: vec_temp => NULL()
    INTEGER                            :: i
    CHARACTER(LEN=ppm_char)            :: caller = "<%= collection_type %>_push"
    REAL(KIND(1.D0))                   :: t0

    CALL substart(caller,t0,info)

    !add the element at the end of the array
    this%min_id = 1
    this%max_id = this%max_id + 1
    this%nb = this%nb + 1
    IF (PRESENT(id)) id = this%max_id

    IF (this%max_id.GT.this%vec_size) THEN
        IF (this%vec_size.LE.0 .OR. .NOT.ASSOCIATED(this%vec)) THEN
            !if the array is empty, allocate with a reasonable size
            this%vec_size = 10
            ALLOCATE(<%= element_ptr_type %>::this%vec(this%vec_size),STAT=info)
        ELSE
            !if the array is full, double its size
            ALLOCATE(vec_temp(this%vec_size),STAT=info)
            $or_fail_alloc("could not allocate temporary array")

            DO i=1,this%vec_size
                SELECT TYPE (t => this%vec(i)%t)
                TYPE IS (<%= element_type %>)
                    vec_temp(i)%t => t
                END SELECT
            ENDDO

            DEALLOCATE(this%vec,STAT=info)
            $or_fail_dealloc("could not deallocate collection array")

            ALLOCATE(<%= element_ptr_type %>::this%vec(2*this%vec_size),STAT=info)
            $or_fail_alloc("could not allocate collection array")

            DO i=1,this%vec_size
                 SELECT TYPE (tmp => vec_temp(i)%t)
                 TYPE IS (<%= element_type %>)
                     this%vec(i)%t => tmp
                 END SELECT
            ENDDO
            this%vec_size = 2 * this%vec_size
            DEALLOCATE(vec_temp,STAT=info)
            $or_fail_dealloc("could not deallocate temporary array")
        ENDIF
    ENDIF

    IF (ASSOCIATED(this%vec(this%max_id)%t)) THEN
        $fail("Pointer at position of new element is already associated. Something wrong in the Collection data structure")
    ENDIF

    SELECT TYPE (e => element)
    TYPE IS (<%= element_type %>)
        this%vec(this%max_id)%t => e
    END SELECT

    IF (.NOT.ASSOCIATED(this%vec(this%max_id)%t)) THEN
       $fail("Pushing element into collection failed unexpectedly")
    ENDIF

    element => NULL()

    CALL substop(caller,t0,info)
    9999 CONTINUE

END SUBROUTINE
!REMOVE
SUBROUTINE <%= collection_type %>_remove(this,info,id)
    !!! remove the current element (as defined by the iterator pointer)
    !!! from the collection
    CLASS(<%= collection_type %>)      :: this
    INTEGER,          INTENT(  OUT)    :: info
    INTEGER,OPTIONAL, INTENT(IN   )    :: id

    INTEGER                            :: del_id
    !deallocate the element
    !CALL this%vec(id)%destroy(info)
    IF (PRESENT(id)) THEN
        del_id = id
    ELSE
        del_id = this%iter_id
    ENDIF
    SELECT TYPE (t => this%vec(del_id)%t)
    TYPE IS (<%= element_type %>)
        CALL t%destroy(info)
    END SELECT
    !swap with the last non-empty element of the collection
    IF (this%max_id.GT.this%min_id) THEN
        SELECT TYPE(t_last => this%vec(this%max_id)%t)
        TYPE IS (<%= element_type %>)
            SELECT TYPE(t_del => this%vec(del_id)%t)
            TYPE IS (<%= element_type %>)
                t_del= t_last
            END SELECT
        END SELECT
    ENDIF

    this%nb = this%nb - 1
    this%max_id = this%max_id - 1
    this%iter_id = this%iter_id - 1
    IF (this%nb.EQ.0 .OR. this%max_id.EQ.0) this%min_id = 0

END SUBROUTINE
end macro
