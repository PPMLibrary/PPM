macro ppm_fail(message, type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
CALL ppm_error(<%= type %>, &
  <%= message %>,&
  <%= caller %>, 10000 , <%= info %>)
GOTO <%= exit_point %>
end macro

macro fail(message, type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
<%= info %> = ppm_error_error
$ppm_fail(<%=message%>,<%=type%>,<%=info%>,<%=exit_point%>,<%=caller%>)
end macro

macro or_fail(message, type=ppm_err_sub_failed,info=info)
IF (<%= info %>.NE.0) THEN
  $ppm_fail(<%=message%>,<%=type%>,<%=info%>)
END IF
end macro

macro or_fail_alloc(message, type=ppm_err_alloc,info=info)
IF (<%= info %>.NE.0) THEN
  $ppm_fail(<%=message%>,<%=type%>,<%=info%>)
END IF
end macro

macro or_fail_dealloc(message, type=ppm_err_dealloc,info=info)
IF (<%= info %>.NE.0) THEN
  $ppm_fail(<%=message%>,<%=type%>,<%=info%>)
END IF
end macro

macro dealloc_pointer(p,info=info)
IF (ASSOCIATED(<%= p %>)) DEALLOCATE(<%= p %>,stat=<%= info %>)
$or_fail_dealloc("<%= p %>")
end macro

macro dealloc_allocatable(p,info=info)
IF (ALLOCATED(<%= p %>)) DEALLOCATE(<%= p %>,stat=<%= info %>)
$or_fail_dealloc("<%= p %>")
end macro

macro dealloc_pointers(list)
% list.to_s.split(',').each do |ptr|
$dealloc_pointer(<%= ptr %>)
% end
end macro

macro check_associated(p,message="",type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
% scope.var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% p_s = p.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (.NOT.ASSOCIATED(<%= p_s %>)) THEN
    WRITE(cbuf,*) &
       & "check failed:",   CHAR(10),&
       & "    <%= p_s %> is not associated.", CHAR(10),&
       & <%= message %> 
   $fail(cbuf,ppm_err_argument,info=<%=info%>,<%=exit_point%>) 
ENDIF
end macro

macro check_associated_noscope(p,message="default",type=ppm_err_argument,info=info,exit_point=9999,caller=caller)
% p_s = p.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (.NOT.ASSOCIATED(<%= p_s %>)) THEN
   $fail("<%=p_s%> is not associated. ",ppm_err_argument,info=<%=info%>,<%=exit_point%>) 
ENDIF
end macro

macro check_equal(a,b,message,info=info,exit_point=9999)
% scope.var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% a_s = a.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
% b_s = b.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (<%= a_s %> .NE. <%= b_s%>) THEN
   WRITE(cbuf,*) &
       & "equality check failed:",   CHAR(10),&
       & "    <%= a_s %> = ",<%= a_s %>, CHAR(10),&
       & "    <%= b_s %> = ",<%= b_s %>,&
       & <%= message %> 
   $fail(cbuf,ppm_err_argument,<%=info%>,<%=exit_point%>) 
ENDIF
end macro

macro check_true(a,message,info=info,exit_point=9999)
% scope.var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% a_s = a.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (.NOT.<%= a_s %>) THEN
   WRITE(cbuf,*) &
       & "check failed:",   CHAR(10),&
       & "    <%= a_s %> is not true. ",&
       & <%= message %> 
   $fail(cbuf,ppm_err_argument,<%=info%>,<%=exit_point%>) 
ENDIF
end macro

macro check_false(a,message,info=info,exit_point=9999)
% scope.var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% a_s = a.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )
IF (<%= a_s %>) THEN
   WRITE(cbuf,*) &
       & "check failed:",   CHAR(10),&
       & "    <%= a_s %> is not true",&
       & <%= message %> 
   $fail(cbuf,ppm_err_argument,<%=info%>,<%=exit_point%>) 
ENDIF
end macro

macro start_subroutine(name=default_name)
REAL(KIND(1.D0))                   :: t0
CHARACTER(LEN=ppm_char)            :: caller = "<%= name.to_s.gsub( /\A"/m, "" ).gsub( /"\Z/m, "" )%>"

!-------------------------------------------------------------------------
!  Initialise
!-------------------------------------------------------------------------
CALL substart(caller,t0,info)
end macro

macro end_subroutine(exit_point=9999)
    CALL substop(caller,t0,info)
    <%= exit_point %> CONTINUE
end macro

macro start_function(name=default_name)
% scope.var info: "INTEGER                 :: info"
    CHARACTER(LEN=ppm_char)            :: caller = <%= name %>

    info = 0
end macro

macro end_function(exit_point=9999)
    <%= exit_point %> CONTINUE
end macro

macro destroy_collection_ptr(collection_pointer)
% coll_ptr = collection_pointer
IF (ASSOCIATED(<%= coll_ptr %>)) THEN
    CALL <%= coll_ptr %>%destroy(info)
        $or_fail_dealloc("<%= coll_ptr %> object")
    DEALLOCATE(<%= coll_ptr %>,STAT=info)
        $or_fail_dealloc("<%= coll_ptr %> pointer")
ENDIF
end macro

macro stdout(*message)
% scope.var cbuf: "CHARACTER(LEN=ppm_char)   :: cbuf"
% if message.is_a? Array
    WRITE(cbuf,*) <%=message.join(",&\n")%>
% end
    CALL ppm_write(ppm_rank,caller,cbuf,info)
end macro

