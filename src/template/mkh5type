#!/usr/bin/perl

# Take a profile of an argument, and generate the required hdf5 code
# to make the data type
# usage
# mkh5type type.def classname [classparent]
use warnings;

my $typename;
my $parenttype;

my %ints;
my %dubs;
my %chars;
my %bool;
my %pointer;
my $spaces= " "x15;
my $tsizeline = $spaces . "tsize = tsize";

my $numarr = 0;

my $calc_section = "";
my $create_section = "";
my $write_section = "";

open FILE, $ARGV[0] or die $!;

for my $line (<FILE>) {
   if ($line =~ m/ *#/) {
      # Ignore comment lines
      next;
   }
   if ($line =~ m/integer (\w*) *(\w*)?/) {
      if ($2) { $ints{$1} = $2; } else { $ints{$1} = '1'; }
   }
   elsif ($line =~ m/real (\w*) *(\w*)?/){
      if ($2) { $dubs{$1} = $2; } else { $dubs{$1} = '1'; }
   }
   elsif ($line =~ m/character *(\w*) *(\w*)?/){
      if ($2) { $chars{$1} = $2; } else { $chars{$1} = '1'; }
   }
   elsif ($line =~ m/logical *(\w*) *(\w*)?/){
      if ($2) { $bool{$1} = $2; } else { $bool{$1} = '1'; }
   }
   elsif ($line =~ m/pointer *(\w*) *(\w*)/){
      $pointers{$1} = $2;
   }
   elsif ($line =~ m/type (\w*)/) {
      $typename = $1;
   }
   elsif ($line =~ m/parent *(\w*)/) {
      $parenttype = $1;
   }
   else {
      die  "Failed to evaluate expr: ".$line
   }
}
$calc_section .= "\n";

#$calc_section .= $spaces . "! Calculate datatype size\n";
if (%ints) {
   $calc_section .= $spaces;
   $calc_section .= "CALL h5tget_size_f(H5T_NATIVE_INTEGER, isize, error)\n";
}
if (%dubs) {
   $calc_section .= $spaces;
   $calc_section .= "CALL h5tget_size_f(H5T_NATIVE_DOUBLE, dsize, error)\n";
}
if (%bool or %chars or %pointers) {
   $calc_section .= $spaces;
   $calc_section .= "CALL h5tget_size_f(H5T_NATIVE_CHARACTER, csize, error)\n";
}

$calc_section .= "\n";
my $hash, my $var, my $count;
my $key;
sub sum_type {
   $hash = $_[0];
   $var = $_[1];
   $count = 0;
   $cline = $var . "*(";
   for $key (keys %$hash) {
      if ($$hash{$key} =~ /\d/){
         $count += $$hash{$key};
      }
      else {
         $cline .= $$hash{$key} . "+";
      }
      #$calc_section .= $key . ' ' . $$hash{$key};
   }
   if ($count > 0 or not $cline eq $var . "*("){
      $tsizeline .= " + ". $cline . $count . ")";
   }
}
&sum_type(\%ints, 'isize');
&sum_type(\%dubs, 'dsize');
&sum_type(\%bool, 'csize');
&sum_type(\%chars, 'csize');
$tsizeline .= " + csize*32*". keys(%pointers);

$calc_section .= "\n";
$calc_section .= $tsizeline . "\n\n";

# Now to make the arguments
$create_section .= $spaces . "! Insert the members\n";
sub print_attr {
   $type = $_[0];
   $names = $_[1];
   for $var (keys %$names){
      print $type."\n";
      if ($type eq "pointer"){
         print_ptr($var);
      }
      elsif ($$names{$var} eq '1'){
         print_el ($var, $type, $_[2]);
      }
      else {
         print_arr($type, $var, $_[2]."*".$$names{$var});
      }
   }
   $create_section .= "\n";
}
sub print_el {
   $type = $_[1];
   if ($type eq "logical"){
      $type = "H5T_NATIVE_CHARACTER"
   }
   $create_section .= $spaces;
   $create_section .= "CALL h5tinsert_f(dtype_id, \"".$_[0]."\", offset, &\n";
   $create_section .= $spaces . "      " . $type .", error)\n";
   $create_section .= $spaces . "offset = offset + ". $_[2] . "\n";
}
sub print_arr {
   $type = $_[0];
   $var = $_[1];
   $num = $_[2];
   $create_section .= $spaces . "dims = (/$num/)\n";
   if ($type eq "H5T_NATIVE_CHARACTER") {
      $create_section .= $spaces . "CALL h5tcreate_f(H5T_STRING_F, $num, &\n";
      $create_section .= $spaces . "    array_id, error)\n";
   }
   else {
      $type =~ s/logical/H5T_NATIVE_CHARACTER/;
      $create_section .= $spaces . "CALL h5tarray_create_f(".$type.", rank, &\n";
      $create_section .= $spaces . "    dims, array_id, error)\n";
   }
   $create_section .= $spaces . "CALL h5tinsert_f(dtype_id, \"".$var."\", offset, &\n";
   $create_section .= $spaces . "    array_id, error)\n";
   $create_section .= $spaces . "offset = offset + (". $num. ")\n";
   $numarr += 1;
}
sub print_ptr {
   $name = $_[0];
   $create_section .= $spaces . "CALL h5tcreate_f(H5T_STRING_F, 32*csize, &\n";
   $create_section .= $spaces . "    array_id, error)\n";
   $create_section .= $spaces . "CALL h5tinsert_f(dtype_id, \"".$name."\", offset, &\n";
   $create_section .= $spaces . "    array_id, error)\n";
   $create_section .= $spaces . "offset = offset + (32*csize)\n";
}

$create_section .= $spaces . "! Integer members\n";
print_attr("H5T_NATIVE_INTEGER", \%ints, "isize");

$create_section .= $spaces . "! Real members\n";
print_attr("H5T_NATIVE_DOUBLE", \%dubs, "dsize");

$create_section .= $spaces . "! Character members\n";
print_attr("H5T_NATIVE_CHARACTER", \%chars, "csize");

$create_section .= $spaces . "! Logical members\n";
print_attr("logical", \%bool, "csize");

$create_section .= $spaces . "! Pointer members\n";
print_attr("pointer", \%pointers, "csize*32");

# Now we generate the code for the write function
for $map (\%ints, \%dubs, \%chars, \%bool) {
   for $key (keys %$map) {
      $write_section .= $spaces . "CALL write_attribute(dset_id, \'$key\', &\n";
      if ($$map{$key} eq '1'){
         $write_section .= $spaces . "    type_ptr%$key)\n";
      }
      else {
         $write_section .= $spaces . "    type_ptr%$key, $$map{$key})\n";
      }
   }
}
for $ptr (keys %pointers) {
   $write_section .= $spaces . "IF (associated(type_ptr%$ptr)) THEN\n";
   $write_section .= $spaces . "   pointer_addr = get_pointer(type_ptr%$ptr)\n";
   $write_section .= $spaces . "   CALL store_$pointers{$ptr}(cpfile_id, &\n";
   $write_section .= $spaces . "       pointer_addr, type_ptr%$ptr)\n";
   $write_section .= $spaces . "ELSE\n";
   $write_section .= $spaces . "   pointer_addr = \"00000000000000000000000000000000\"\n";
   $write_section .= $spaces . "ENDIF\n";
   $write_section .= $spaces . "CALL write_attribute(dset_id, \"$ptr\", pointer_addr, 32)\n";
}

# Now we write the file from the template
if ($ARGV[1]) {
   $typename = $ARGV[1];
}
if ($ARGV[2]) {
   $parenttype = $ARGV[2];
}
if (not $typename) {
   die "No type specified";
}

open TEMPLATE, "+<", "type.f.in" or die $!;
open OUTFILE, ">", $typename . "_check.f" or die $!;

for (<TEMPLATE>) {

   # if its not an omitted line, print
   if (not ((m/isize/ and (not %ints))
          or (m/dsize/ and (not %dubs))
          or (m/csize/ and (not %bool) and (not %chars) and (not %pointers))
          or ((m/array_id/ or m/dims/ or m/rank/) and ($numarr == 0))
          or (m/subsize/ and ($numarr == 0))
          or ((/[sg]et_size/ or /PARENT/i) and (not $parenttype)))) {

      # Make the template substitutions
      $_ =~ s/TYPE/$typename/;
      $_ =~ s/ *!CREATE_STUB/$create_section/;
      $_ =~ s/ *!CALCULATE_STUB/$calc_section/;
      s/ *!WRITE_STUB/$write_section/;
      #s/ *!READ_STUB/$read_section/;
      $_ =~ s/PARENT/$parenttype/;
      print OUTFILE;
   }
}
close TEMPLATE;
close OUTFILE;
